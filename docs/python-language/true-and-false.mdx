---
sidebar_position: 6
---

import CodeBlock from '@theme/CodeBlock';
import true_and_false_1 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_1.py';
import true_and_false_2 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_2.py';
import true_and_false_3 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_3.py';
import true_and_false_4 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_4.py';
import true_and_false_5 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_5.py';
import true_and_false_6 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_6.py';
import true_and_false_7 from '!!raw-loader!/static/examples/python-language/true-and-false/true_and_false_7.py';

# Константы True и False

## Константы `True` и `False`. Тип данных `bool` {#true-and-false-constants-bool-type}

В языке Python есть две константы `True` и `False`, загружаемые в память при запуске интерпретатора (от английского «true» — «истина» и «false» — «ложь»). Проверка выражений на истинность является основой управляющих конструкций `if` и `while`.

Константы `True` и `False` принадлежат к типу данных `bool` (от английского «boolean» — «булев, логический» — слова, образовавшегося от имени английского математика и логика Джорджа Буля, жившего в 19 веке).

Объекты `True` и `False` называются константами, потому что они инициализируются автоматически и каждая из них всегда находится в памяти в единственном экземпляре (об экземплярах пойдёт речь в главе **Объектно-ориентированное программирование**. Попытка удалить их инструкциями `del True` и `del False` возбудит исключение типа `SyntaxError` с сообщением `SyntaxError: cannot delete True` подобно тому, как попытка удалить литерал `1` возбудит исключение типа `SyntaxError` с сообщением `SyntaxError: cannot delete literal`. Можно рассматривать константы как литералы предварительно инициализированных объектов.

Приведём простейший пример управляющей конструкции `if`. Управляющая конструкция `if` работает по принципу:

- если (`if`) выражение истинно (`True`) — выполнить один логический блок кода (последовательность инструкций);
- иначе (`else`), то есть если выражение ложно (`False`) — выполнить другой логический блок кода.

<CodeBlock language="python" title="true_and_false_1.py" showLineNumbers>{true_and_false_1}</CodeBlock>

Пример 1 является иллюстрацией работы условной конструкции `if`.

На строке 4 вводим данные в программу, используя встроенную функцию `input()`. Объявляем глобальную переменную `a` и связываем её с объектом типа `str` (от английского «string» — «строка»), ссылку на который возвращает функция `input()`.

Для преобразования строки в целое число на строке 5 вызываем встроенную функцию `int()`. Функция `int()` в данном случае принимает ссылку на объект типа `str` и возвращает ссылку на другой объект типа `int` (от английского «integer» — «целое число»), полученный из первого объекта согласно правилам преобразования типов. Типы объектов и правила преобразования типов будут подробно описаны в главе **[Встроенные типы данных](/docs/python-language/built-in-data-types)**.

На строке 8 объявлена условная конструкция `if` с проверкой выражения `a == 1`. Читать её следует так:

- если `a` равно `1` (то есть если проверка на равенство `a == 1` возвращает ссылку на объект `True`) — выполнить инструкцию `print(a == 1)`;
- иначе (то есть если проверка на равенство `a == 1` возвращает ссылку на объект `False`) — выполнить инструкцию `print(a == 1)`.

Обычно в программах разные наборы инструкций для блоков `if` и `else`. Тут выполняется одна и та же инструкция в теле условия `if` и в теле условия `else`, чтобы продемонстрировать, что выражение `a == 1` возвращает либо ссылку на объект `True`, либо ссылку на объект `False`.

:::info внимание

Оператор сравнения `==` — не то же самое, что оператор присваивания `=`. Оператор сравнения `==` сравнивает два объекта, а оператор присваивания `=` присваивает переменной ссылку на объект (связывает переменную с объектом).

:::

Инструкции `print(a == 1)`, объявленные на строках 9 и 11, выведет строковое представление объекта `True` или `False` в зависимости от того, какое число мы ввели с клавиатуры.

На строке 14 объявлена глобальная переменная `b`, которая является ссылкой на объект, полученный в результате вычисления выражения `a == 1`.
При выполнении кода на строке 15 будет выведено либо `True`, либо `False` в зависимости от того, какое число было введено с клавиатуры.

На строках 17 и 18 демонстрируется, что переменённая `b` и выражение `a == 1` ссылаются на одну и ту же константу (`True` или `False` в зависимости от того, какое число было введено с клавиатуры). Интерпретатор выведет один и тот же идентификатор. Поскольку константы `True` и `False` загружаются в оперативную память при запуске интерпретатора, в каком месте программы мы бы ни вызвали `id(True)` или `id(False)`, везде функция `id()` вернёт те же идентификаторы, которые были присвоены константам при инициализации. И, поскольку это встроенные константы, попытка удалить их инструкцией `del True` или `del False` возбудит исключение типа `SyntaxError`.

Управляющая конструкция `if` будет рассмотрена подробно в следующем разделе, здесь только приведён пример для того, чтобы было понятно, для чего нужны константы `True` и `False`.

:::info внимание

В примере допущено упрощение: в конструкциях `if` и `while` можно применять выражения, возвращающие ссылки на объекты разных типов, а не только на константы `True` и `False`. При проверке условий в конструкциях `if` и `while` выполняется алгоритм преобразования объектов к булеву типу данных (то есть к константам `True` или `False`). Любой объект Python может быть проверен на истинность и преобразован к булеву типу данных в соответствии с правилами преобразований типов данных. Об этом будет подробно изложено ниже в главе **[Операторы](/docs/python-language/operators)**.

:::

## Операторы сравнения `<`, `<=`, `>`, `>=`, `==`, `!=` {#comparison-operators}

Выше в качестве примера мы рассматривали только оператор сравнения `==` (проверка на равенство). В таблице 1 приводится полный список операторов сравнения в Python.

### Таблица 1. Операторы сравнения {#table-1-comparison-operators}

| Оператор | Описание         |
| ---------| -----------------|
| `<`      | Меньше           |
| `<=`     | Меньше или равно |
| `>`      | Больше           |
| `>=`     | Больше или равно |
| `==`     | Равно            |
| `!=`     | Не равно         |

Операторы сравнения возвращают ссылку на объект `True` или `False` в зависимости от того, выполняется условие или нет.

Операторы сравнения применяются совместно с переменными и литералами. То есть можно сравнить:

- `a < b` (переменную и переменную);
- `a < 1` (переменную и литерал);
- `1 < 2` (литерал и литерал).

<CodeBlock language="python" title="true_and_false_2.py" showLineNumbers>{true_and_false_2}</CodeBlock>

Рассмотрим пример 2.

На строках 7 — 12 производится сравнение объекта, на который ссылается переменная `a` с объектом, объявленным через литерал `1`.

В зависимости от того, какое число ввёл пользователь, интерпретатор выведет строковое представление констант `True` и `False`.

На строке 13 результат сравнения связывается с переменной `b`.

## Операторы идентичности `is`, `is not` {#identity-operators}

### Таблица 2. Операторы идентичности {#table-2-identity-operators}

| Оператор | Описание             |
| ---------| ---------------------|
| `is`     | Объекты идентичны    |
| `is not` | Объекты не идентичны |

Чтобы выполнять проверки идентичности сравниваемых объектов, в Python применяются операторы `is` и `is not`.

Нам уже известно, что встроенная функция `id()` применяется для вычисления идентификатора объекта. Операторы идентичности используют идентификаторы объектов, возвращаемые функцией `id()`, и сравнивают их. То есть выражение `a is b` эквивалентно выражению `id(a) == id(b)`.

Оператор `is` вернёт ссылку на константу `True`, если сравниваемые операнды ссылаются на один и тот же объект и `False`, если операнды ссылаются на разные объекты.

Оператор `is not` вернёт ссылку на константу `True`, если сравниваемые операнды ссылаются на разные объекты, и `False` — если операнды ссылаются на один объект.

Операторы `is` и `is not` используются для сравнения переменных или результатов работы функций. Если использовать операторы `is` и `is not` с литералами, интерпретатор Python выполнит операцию, но возбудит исключение типа `SyntaxWarning` (предупреждение). Для операций с литералами вместо оператора `is` интерпретатор предлагает использовать оператор сравнения `==`, а вместо оператора `is not` — оператор сравнения `!=`.

<CodeBlock language="python" title="true_and_false_3.py" showLineNumbers>{true_and_false_3}</CodeBlock>

В примере 3 на строках 4 и 5 объявляются переменные `a` и `b`.

На строках 8 и 9 выводятся идентификаторы объектов, на которые ссылаются эти переменные.

На строках 12 — 19 приводятся примеры использования операторов `is` и `is not`.

На строках 22 и 23 приводятся примеры использования операторов `is` и `is not` с литералами. Интерпретатор выполнит инструкции, но возбудит исключения типа `SyntaxWarning` с сообщениями, в которых предлагается вместо операторов идентичности `is` и `is not` использовать операторы сравнения `==` и `!=`.

:::info внимание

Текущая реализация CPython хранит в оперативной памяти инициализированные при запуске интерпретатора целочисленные объекты в диапазоне между `-5` и `256`. Поэтому при создании переменной, ссылающейся на целое число в данном диапазоне, новый объект числа не создаётся, а создаётся ссылка на уже существующий в памяти объект. Если же переменная ссылается на число, выходящее за пределы этого диапазона, в оперативной памяти создаётся новый целочисленный объект и связывается с этой переменной.

:::

Поэтому, если запустить интерпретатор в интерактивном режиме и вручную ввести следующие команды, мы увидим, что интерпретатор выведет `True` при проверке на идентичность переменных, ссылающихся на целочисленные объекты в пределах диапазона, и выведет `False` при проверке на идентичность переменных, ссылающихся на целочисленные объекты за пределами диапазона:

```python showLineNumbers
>>> a = 256
>>> b = 256
>>> a is b
True
>>> a = 257
>>> b = 257
>>> a is b
False
>>> a = -5
>>> b = -5
>>> a is b
True
>>> a = -6
>>> b = -6
>>> a is b
False
```

Однако, если мы запишем эти команды в файл и выполним, интерпретатор четыре раза выведет `True`. Это особенность реализации CPython.

Поэтому не следует полагаться на оператор идентичности при проверке целых чисел на равенство. Вместо этого нужно воспользоваться оператором сравнения `==`.

## Логические (булевы) операторы `and`, `or` и `not` {#logical-boolean-operators}

Python поддерживает следующие логические операции с выражениями:

- логическое И — оператор `and`;
- логическое ИЛИ — оператор `or`;
- логическое НЕ — оператор `not`.

Логические операторы `and`, `or` и `not` позволяют составлять сложные выражения, комбинируя в одном выражении несколько проверок с использованием операторов, относящихся к другим типам. В основе работы логических операторов лежит стандартный алгоритм проверки объектов на истинность. Любой объект Python может быть проверен на истинность и преобразован к булеву типу данных (то есть к константам `True` или `False`).

Этот же алгоритм используется во встроенной функция `bool()`, возвращающей ссылку на константу `True` или `False` в зависимости от результата преобразования передаваемого в функцию объекта. По умолчанию любой объект является истинным, за исключением констант `None` и `False`, нуля любого числового типа, пустых последовательностей и коллекций. О правилах преобразований встроенных типов будет рассказано подробно в главе **[Встроенные типы данных](/docs/python-language/built-in-data-types)**.

В таблицах 3, 4 и 5 показано, как работают логические операторы `and`, `or` и `not`. Буквы `a` и `b` в этих таблицах означают различные выражения с применением всего многообразия языковых средств Python (включая вызовы функций и методов).

### Таблица 3. Операция `a and b` {#table-3-a-and-b-operation}

| `a`     | `a and b` |
| ------- | --------- |
| `False` | `a`       |
| `True`  | `b`       |

Рассмотрим таблицу 3.

В Python логическая операция `and` работает так:

- интерпретатор вычисляет выражение слева от оператора `and` (получает ссылку на объект, полученный в результате вычисления) и преобразует результат к булеву типу;
- если результат преобразования к булеву типу выражения слева от оператора `and` равен `False`, интерпретатор возвращает ссылку на объект, полученный в результате вычисления;
- в противном случае, то есть если результат преобразования к булеву типу выражения слева от оператора `and` равен `True`, интерпретатор вычисляет выражение справа от оператора `and` и возвращает ссылку на объект, полученный в результате этого вычисления.

<CodeBlock language="python" title="true_and_false_4.py" showLineNumbers>{true_and_false_4}</CodeBlock>

В примере 4 на строке 3 результат вычисления будет равен `0`, поскольку преобразование результата вычисления выражения `1 - 1` слева от оператора `and` к булеву типу возвращает `False`. Как было сказано выше, нуль любого типа при проверке истинности преобразуется в `False`. Это продемонстрировано на строке 4.

На строке 6 результат вычисления будет равен `7`, поскольку преобразование результата вычисления выражения `1 + 2` слева от оператора `and` к булеву типу возвращает `True`. Любое число (в том числе отрицательные числа) кроме нуля при проверке истинности преобразуется в `True`. Это продемонстрировано на строке 7.

На строках 10 и 14 объявлены функции `minus()` и `plus()`, возвращающие ссылки на объекты, полученные в результате сложения или вычитания передаваемых аргументов.

На строках 18 и 21 продемонстрировано использование оператора `and` в выражениях, включающих вызовы функций. Результаты вычислений на строках 18 и 21 идентичны результатам вычислений на строках 3 и 6. На строках 19 и 22 показано, что преобразования к булеву типу вызовов функций `minus()` и `plus()` дают те же результаты, что на строках 4 и 7.

### Таблица 4. Операция `a or b` {#table-4-a-or-b-operation}

| `a`     | `a or b` |
| ------- | -------- |
| `False` | `b`      |
| `True`  | `a`      |

Рассмотрим таблицу 4.

Логическая операция `or` выполняет действие, противоположное действию, выполняемому операцией `and`:

- интерпретатор вычисляет выражение слева от оператора `or` (получает ссылку на объект, полученный в результате вычисления) и преобразует результат к булеву типу;
- если результат преобразования к булеву типу выражения слева от оператора `or` равен `False`, интерпретатор вычисляет выражение справа от оператора `or` и возвращает ссылку на объект, полученный в результате этого вычисления$
- в противном случае, то есть если результат преобразования к булеву типу выражения слева от оператора `or` равен `True`, интерпретатор возвращает ссылку на объект, полученный в результате вычисления слева от оператора `or`.

<CodeBlock language="python" title="true_and_false_5.py" showLineNumbers>{true_and_false_5}</CodeBlock>

В примере 5 на строке 3 результат вычисления будет равен `4`, поскольку преобразование результата вычисления выражения `1 - 1` слева от оператора `or` к булеву типу возвращает `False`.

На строке 6 результат вычисления будет равен `3`, поскольку преобразование результата вычисления выражения `1 + 2` слева от оператора `or` к булеву типу возвращает `True`.

Результаты вычислений на строках 18 и 21 идентичны результатам вычислений на строках 3 и 6.

### Таблица 5. Операция `not a` {#table-5-not-a-operation}

| `a`     | `not a` |
| ------- | ------- |
| `False` | `True`  |
| `True`  | `False` |

Рассмотрим таблицу 5.

Логическая операция `not` всегда возвращает ссылку на `True` или `False`:

- возвращает ссылку на константу `True`, если преобразование к булеву типу выражения `a` возвращает ссылку на константу `False`;
- в противном случае возвращает ссылку на константу `False`.

<CodeBlock language="python" title="true_and_false_6.py" showLineNumbers>{true_and_false_6}</CodeBlock>

В примере 6 на строках 3 и 4 показан результат вызова оператора `not` применительно к булевым константам.

На строках 6 и 7  — оператор `not` применительно к вещественным числам.

На строках 9 и 10 — оператор `not` применительно к строкам.

На строках 17 и 18 — оператор `not` применительно к вызову функции.

На строках 20 и 21 показано двойное отрицание, возвращающее тот же результат, что преобразование к булеву типу с использованием функции `bool()`.

<CodeBlock language="python" title="true_and_false_7.py" showLineNumbers>{true_and_false_7}</CodeBlock>

При запуске скрипта с примером 7 три раза будет выведена фраза «Условие выполнено».

На строках 8, 13 и 18 показано использование логических операторов `and`, `or` и `not` совместно с операторами сравнения в управляющей конструкции `if`.

Такое использование возможно благодаря тому, что у операторов сравнения, `and`, `or` и `not` разные приоритеты, о чём будет подробно изложено в следующей главе.

## Дополнительные ссылки {#additional-links}

- [Константа](https://ru.wikipedia.org/wiki/Константа_(программирование))
- [Булева алгебра](https://ru.wikipedia.org/wiki/Булева_алгебра)
- [Алгебра логики](https://ru.wikipedia.org/wiki/Алгебра_логики)
- [Джордж Буль](https://ru.wikipedia.org/wiki/Буль,_Джордж)
- [Таблица истинности](https://ru.wikipedia.org/wiki/Таблица_истинности)
- [Дизъюнкция](https://ru.wikipedia.org/wiki/Дизъюнкция)
- [Конъюнкция](https://ru.wikipedia.org/wiki/Конъюнкция)
- [Отрицание](https://ru.wikipedia.org/wiki/Отрицание)
