---
sidebar_position: 3
---

import CodeBlock from '@theme/CodeBlock';
import variables_and_objects_1 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_1.py';
import variables_and_objects_2 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_2.py';
import variables_and_objects_3 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_3.py';
import variables_and_objects_4 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_4.py';
import variables_and_objects_5 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_5.py';
import variables_and_objects_6 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_6.py';
import variables_and_objects_7 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_7.py';
import variables_and_objects_8 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_8.py';
import variables_and_objects_9 from '!!raw-loader!/static/examples/python-language/variables-and-objects/variables_and_objects_9.py';

# Переменные и объекты

Разберём пример использования переменных.

<CodeBlock language="python" title="variables_and_objects_1.py" showLineNumbers>{variables_and_objects_1}</CodeBlock>

В файле `variables_and_objects_1.py` на строке 3 объявлена (введена в программу) переменная `a`.

**Переменная** в языке Python — это именованная (имеющая название) ссылка на объект.

Переменные используются в языках программирования как способ доступа к данным, обрабатываемым в программах.

Способ объявления переменной в Python: `<переменная> = <объект>`.

Выражение `a = 1` означает, что интерпретатор Python во время выполнения программы должен:

- найти переменную `a`, если она есть;
- или создать переменную `a`, если её ещё нет;
- найти в оперативной памяти объект `1`, если он есть;
- или создать (инициализировать) объект `1`, если его ещё нет;
- связать переменную `a` с объектом `1` (создать ссылку).

Если сказать проще, выражение `a = 1` означает, что нужно найти или создать переменную `a`, найти или создать объект `1` и связать переменную `a` с объектом `1`.

В таком случае говорят: переменная `a` ссылается на объект `1`.

Переменная позволяет нам обратиться к объекту по имени. Можно сказать, что переменная — это имя объекта.

**Объект** в языке Python — это способ организации данных. Объект содержит данные и функционал. Это определение слишком обобщённое, чтобы из него можно было что-то понять. Мы будем разбирать объекты подробно на протяжении всего учебника. Пока запомните, что объект — это способ организации данных в языке Python. В других языках программирования тоже есть объекты, и реализации объектов очень различаются в разных языках.

**Инициализация объекта** — создание объекта в оперативной памяти во время выполнения программы.

Разберём составные части выражения `a = 1`.

**Выражение** — законченный по смыслу фрагмент программы.

Выражение складывается из составных частей — лексем.

Лексемы выражения:

- `a` — переменная (ссылка на объект);
- `=` — оператор присваивания;
- `1` — литерал объекта.

**Лексема** — составная часть выражения. Лексема — это общее название для разных частей языка (переменных, операторов, литералов, функций, классов и т.д.).

Если сравнить язык Python с русским языком, выражение — это предложение, а лексемы — это члены предложения.

**Оператор** — один из элементов выражения, выполняющий какое-то действие (операцию) с другими частями выражения (операндами).

Операторы объединяются в группы по характеру операций, которые они выполняют.

### Таблица 1. Операторы в Python {#table-1-python-operators}

| Операторы | Описание |
| ----------| -------- |
| `+`, `-`, `*`, `**`, `/`, `//`, `%`, `@` | арифметические операторы |
| `<<`, `>>`, `&`, <code>&#124;</code>, `^`, `~` | побитовые операторы |
| `=`, `:=`, `+=`, `-=`, `*=`, `**=`, `/=`, `//=`, `%=`, `@=`, `<<=`, `>>=`, `&=`, <code>&#124;=</code>, `^=` | операторы присваивания |
| `<`, `<=`, `>`, `>=`, `==`, `!=` | операторы сравнения |
| `is`, `is not` | операторы идентичности |
| `in`, `not in` | операторы принадлежности |
| `or`, `and`, `not` | логические операторы |

**Оператор присваивания** в выражении `a = 1` — оператор, связывающий переменную с объектом. Он присваивает объекту `1` имя `a`.

**Литерал** — форма записи объекта в тексте программы.

Формы записи объекта зависит от типа объекта. По литералу в тексте программы можно понять, к какому типу принадлежит объект.

Например, литералы числовых типов:

- `1` — литерал объявления целых чисел;
- `1.0` — литерал объявления чисел с плавающей точкой (с дробной частью).

Примеры литералов списков:

- `[]` — литерал пустого списка;
- `['a', 'b', 'c']` — литерал списка из трёх элементов.

Пустой список также можно создать, вызвав встроенную функцию `list()`, но это уже не литерал, а вызов функции.

Ещё пример: `{'a', 'b', 'c'}` — литерал множества из трёх элементов.

Но пустое множество с помощью литерала создать нельзя. Оно создаётся при помощи вызова встроенной функции `set()`.

Один тип объектов может иметь несколько разных литералов.

Например, объект типа `str` (строка) может быть записан с использованием следующих литералов:

- `'строка в одинарных кавычках с возможностью вставлять "двойные" кавычки внутри строки'`;
- `"строка в двойных кавычках с возможностью вставлять 'одинарные' кавычки внутри строки"`;
- `'''одна или несколько строк в тройных одинарных кавычках с возможностью вставлять 'одинарные' и "двойные" кавычки внутри строки'''`;
- `"""одна или несколько строк в тройных двойных кавычках с возможностью вставлять 'одинарные' и "двойные" кавычки внутри строки"""`.

Вернёмся ещё раз к нашему примеру и рассмотрим программу построчно с начала и до конца.

<CodeBlock language="python" title="variables_and_objects_1.py" showLineNumbers>{variables_and_objects_1}</CodeBlock>

Первая строка файла `variables_and_objects_1.py` начинается с символа `#` — этот символ указывает на то, что строка содержит комментарий.

**Комментарий** — это строка, которая содержит служебную информацию или произвольный текст и игнорируется интерпретатором при выполнении программы.

Для чего нужны комментарии? В них мы можем писать заметки по ходу программы, объяснять, что делают те или иные блоки кода.

Также мы можем поместить внутрь комментариев (закомментировать) неиспользуемые блоки кода, которые нам могут потом пригодиться, вместо того чтобы каждый раз удалять их, а потом снова вносить в программу.

Первая строка с комментарием — это строка shebang. Об этом было написано в секции **[Как запускать программы, написанные на Python](/docs/python-language/installing-and-configuring/how-to-run-python-programs)**.

Строка shebang будет встречаться во всех примерах, потому что все примеры программ в этом учебнике рассчитаны на запуск как в Windows, так и в Linux.

Пользователи Windows могут не беспокоиться по поводу строки shebang, потому что строка shebang в Windows игнорируется интерпретатором командной строки и не влияет на выполнение программы.

Вторая строка — пустая. Интерпретатор игнорирует пустые строки. Их вставляют для удобства чтения программы, чтобы отделить друг от друга длинные блоки кода.

Начиная с третьей строки идёт текст программы, который будет выполнен интерпретатором Python.

Третью строку мы уже рассмотрели: в ней объявляется переменная `a`, ссылающаяся на объект `1`. По литералу объекта мы понимаем, что тип объекта — целое число.

Четвёртая строка — вызов встроенной функции [`print()`](https://docs.python.org/3/library/functions.html#print).

Встроенная функция `print()` принимает в качестве аргумента переменную `a` и выводит на экран объект `1`, поскольку именно на него ссылается переменная `a`.

**Функция** в Python — именованный (имеющий название) объект, содержащий алгоритм (набор действий). В других языках определения функции отличаются. Наиболее общее определение, подходящее для всех языков программирования: функция — именованный алгоритм.

Функции бывают встроенные и пользовательские. Встроенные функции созданы авторами языка. Пользовательские функции создаются программистами, пишущими на языке.

Встроенные функции содержат наиболее часто используемые алгоритмы, которые нужны практически в каждой программе. Пользовательские функции — это функции, создаваемые для решения частных задач, стоящих перед программистами.

В следующих разделах мы научимся использовать встроенные функции языка Python, а также создавать свои функции и пользоваться ими.

Функция может выполнять какие-либо действия с объектами, ссылки на которые передаются в функцию и называются аргументами.

**Аргумент** в Python — ссылка на объект, передаваемая в функцию для обработки. Форма записи вызова функции с аргументом: `<функция>(<аргумент>)`.

В других языках определения аргумента отличаются. Наиболее общее определение, подходящее для всех языков программирования: аргумент — данные, передаваемые в программу или подпрограмму для обработки.

На четвёртой строке переменная `a` — аргумент, передаваемый в функцию `print()`.

На четвёртой строке после выражения `print(a)` записан комментарий.

Комментарий можно объявлять на одной строке с инструкцией. Все символы после знака `#` (знак объявления комментария) будут игнорироваться интерпретатором.

После инструкции перед знаком `#` принято ставить два пробела. О правилах оформления кода речь пойдёт ниже.

Пятая строка — вызов оператора `del`, удаляющего переменную `a` из оперативной памяти.

:::info внимание

Удаляется переменная `a`, а не объект `1`, на который ссылается эта переменная.

:::

После удаления переменной сам объект может продолжать находиться в оперативной памяти, если есть другие переменные, которые ссылаются на него.

Если при удалении переменной не осталось других ссылок на этот объект, интерпретатор помечает этот объект как готовый к удалению из оперативной памяти.

Во время выполнения программы интерпретатор Python периодически запускает механизм, удаляющий из памяти объекты, на которые не осталось ссылок, и освобождает память. Это называется «сборка мусора».

**Сборка мусора** — механизм автоматического удаления из оперативной памяти тех объектов, на которые нет ни одной ссылки.

На самом деле некоторые объекты, на которые не ссылается ни одна переменная, могут оставаться в памяти даже после сборки мусора. Некоторые часто используемые объекты постоянно находятся в памяти, потому что в любой момент может понадобиться создать ссылку на них. Это сделано для того, чтобы повысить производительность интерпретатора, так как инициализация объекта занимает процессорное время, а создание ссылки на уже инициализированный объект — гораздо более быстрая операция.

Давайте немного поменяем программу.

<CodeBlock language="python" title="variables_and_objects_2.py" showLineNumbers>{variables_and_objects_2}</CodeBlock>

В файле `variables_and_objects_2.py` на четвёртой строке объявляем переменную `b`.

Выражение `b = a` означает, что переменная `b` ссылается на тот же объект `1`, что и переменная `a`.

:::info внимание

Переменную в Python можно объявлять в любом месте программы.

:::

На пятой строке мы удаляем переменную `a`, а на шестой строке вызываем функцию `print(b)` и выводим на экран объект `1`, который по-прежнему находится в оперативной памяти.

<CodeBlock language="python" title="variables_and_objects_3.py" showLineNumbers>{variables_and_objects_3}</CodeBlock>

Разберём пример `variables_and_objects_3.py`.

В Python инструкции разбиваются на строки. Обычно одна строка — это одна инструкция.

В текстовых файлах с исходным кодом в конце каждой строки стоит символ перевода строки. Этот символ, как и символ пробела, обычно не отображается в текстовом редакторе, но можно настроить редактор так, чтобы видеть эти символы.

Символ перевода строки указывает интерпретатору Python, где заканчивается текущая инструкция.

Можно объединять несколько инструкций в одну строку, если ставить в конце инструкции знак `;` (точка с запятой).

:::info внимание

На четвёртой строке точка с запятой не стоит после выражения `a = c`, и это не является ошибкой, поскольку это выражение — последнее на этой строке. Символ перевода строки укажет интерпретатору, что тут инструкция заканчивается.

:::

Если после выражения стоят пробелы — они игнорируются интерпретатором (однако желательно не загромождать программу лишними пробелами).

Объединять инструкции на одной строке и ставить точки с запятой после выражений можно, но это считается **плохой практикой**, так как ухудшает читаемость программы. Поэтому старайтесь этого избегать.

На пятой строке интерпретатор выведет `2`, потому что на четвёртой строке в выражении `a = c` указали интерпретатору, что переменная `a` больше не должна ссылаться на объект `1`, а должна ссылаться на объект `2`, на который ссылается переменная `c`.

Из примера видно, что мы можем делать так, чтобы одна и та же переменная ссылалась на разные объекты прямо по ходу написания программы, и нам не нужно её для этого удалять и объявлять заново.

:::info внимание

В файле `variables_and_objects_3.py` мы нигде не удаляем переменные явно. Сборщик мусора интерпретатора Python сам удаляет объекты из памяти после выполнения программы.

:::

Вернёмся к нашей программе и ещё раз поменяем её.

<CodeBlock language="python" title="variables_and_objects_4.py" showLineNumbers>{variables_and_objects_4}</CodeBlock>

Разобрав пример `variables_and_objects_4.py`, посмотрим, что будет, если удалить переменную, а потом попытаться вывести на экран объект, на который она ссылалась.

На строке 4 мы удаляем переменную `a`, а на строке 5 пытаемся её вывести на экран.

Строки с седьмой по тринадцатую содержат многострочный комментарий. В нём записано, что выведет интерпретатор Python, если мы запустим программу из примера 4.

Многострочные комментарии заключаются с двух сторон в три двойные (`"""` и `"""`) или одинарные (`'''` и `'''`) кавычки. Строго говоря, это литерал строки, на который не ссылается ни одна переменная, и поэтому он игнорируется интерпретатором и ведёт себя как комментарий. Но это рассмотрим позже.

Итак, при попытке обратиться к несуществующей переменной во время выполнения программы возникает исключительная ситуация, и интерпретатор выводит на экран отладочную информацию об ошибке.

При возникновении ошибки интерпретатор выводит информацию из специального объекта типа `Traceback`, предназначенного для обработки ошибок.

Объект типа `Traceback` содержит информацию, что в файле `./variables4.py`, находящейся в текущем каталоге, на строке 5 при попытке вызова функции `print(a)` произошла ошибка типа `NameError`. Дальше выводится сообщение: `name 'a' is not defined`, что означает: `имя 'a' не определено` в программе.

Как видите, нам не нужно тратить время на поиск ошибки, пытаясь понять, что в программе сделано неправильно. Интерпретатор Python сам сообщает нам, в каком файле и на какой строке ошибка, а также тип и описание ошибки.

Умение понимать отладочные сообщения — важный навык программиста. По этим сообщениям можно понять, почему программа не работает, и исправить ошибку.

Подробнее об обработке ошибок речь пойдёт ниже.

В примере 5 исправим нашу программу.

<CodeBlock language="python" title="variables_and_objects_5.py" showLineNumbers>{variables_and_objects_5}</CodeBlock>

Что нужно сделать, чтобы исправить ошибку из примера 4 и вывести на экран объект `1`, на который ссылается переменная `a`?

Убрать инструкцию `del a`, удаляющую переменную `a`.

Это можно сделать двумя способами:

- удалить строку 4 с инструкцией `del a` из программы;
- закомментировать ненужную инструкцию на строке 4, как показано в этом примере.

Теперь инструкция `del a` закомментирована и игнорируется интерпретатором, и, если запустить программу, когда интерпретатор дойдёт до выполнения инструкции на строке 5, он вызовет функцию `print(a)`  выведет `1`.

Интерпретатор Python игнорирует пробелы в выражениях, поэтому мы можем записывать выражения без пробелов, как показано в примере 6.

<CodeBlock language="python" title="variables_and_objects_6.py" showLineNumbers>{variables_and_objects_6}</CodeBlock>

Однако запись выражений без пробелов ухудшает читаемость кода и считается **плохой практикой**. Поэтому старайтесь этого избегать.

<CodeBlock language="python" title="variables_and_objects_7.py" showLineNumbers>{variables_and_objects_7}</CodeBlock>

Рассмотрим пример 7.

Язык Python позволяет использовать множественное присваивание ради сокращения текста программы.

На строке 3 мы объявляем три переменные `a`, `b` и `c` и связываем их с объектами `1`, `2` и `3`.

На строке 4 мы передаём в функцию `print()` переменные `a`, `b` и `c`, записав их через запятую.

Функция `print()` может принимать произвольное количество аргументов, указанных через запятую, и выводит их в том порядке, в котором они были переданы.

При выводе объекты, переданные в функцию, разделяются символом пробела. В конце к строке вывода автоматически добавляется символ перевода строки.

Это сделано для удобства программиста, чтобы каждый раз не передавать в функцию символ перевода строки в тексте программы, как принято в большинстве других языков.

На строках 7 и 8 сделано то же самое, но без использования пробелов в выражениях и между аргументами функции `print()`. Интерпретатор игнорирует пробелы, но такое оформление кода ухудшает читаемость программы.

:::info внимание

Несмотря на то, что на строке 8 мы не поставили пробелы между аргументами функции `print()`, функция всё равно выведет на экран строку с пробелами. Пробелы между аргументами не влияют на поведение функции.

:::

<CodeBlock language="python" title="variables_and_objects_8.py" showLineNumbers>{variables_and_objects_8}</CodeBlock>

Рассмотрим пример 8.

На строке 3 объявлена переменная `a`.

На строке 4 повторно объявляем переменную `a`. Объект, на который ссылается эта переменная, является результатом сложения объекта `1`, на который ссылалась переменная `a`, с самим собой.

Интерпретатор выведет: `2`.

## Идентификаторы объектов. Встроенная функция `id()` {#object-identifiers-built-in-function-id}

В Python есть встроенная функция [`id()`](https://docs.python.org/3/library/functions.html#id), возвращающая целое число — идентификатор объекта. В реализации [CPython](https://ru.wikipedia.org/wiki/CPython) (эталонная реализация интерпретатора Python, которой мы пользуемся) — это адрес объекта в оперативной памяти. В других реализациях (таких, как [PyPy](https://ru.wikipedia.org/wiki/PyPy)) могут быть иные принципы вычисления идентификатора объекта, но поведение функции будет таким же. Идентификатор каждого объекта уникальный и неизменный в течение всей жизни объекта (то есть в течение всего времени, когда объект находится в оперативной памяти). После того, объект удалён из оперативной памяти, другой объект, созданный позднее, может иметь этот же идентификатор. Но два одновременно существующих объекта не могут иметь один идентификатор.

<CodeBlock language="python" title="variables_and_objects_9.py" showLineNumbers>{variables_and_objects_9}</CodeBlock>

Рассмотрим пример 9.

На строке 3 объявляем переменную `a`, которая ссылается на объект `1`. На строке 4 выводим идентификатор объекта, на который ссылается переменная `a`.

На строке 6 объявляем переменную `b`, ссылающуюся на тот же объект, что переменная `a`. На строке 7 выводим идентификатор объекта, на который ссылается переменная `b` и убеждаемся, что выводится тот же идентификатор, который был выведен при выполнении кода на строке 4.

На строке 9 заново объявляем переменную `a`/ Теперь она ссылается на объект, полученный в результате сложения объекта `1` с самим собой. На строке 10 выводим идентификатор объекта `2` и видим, что он не совпадает с прежним идентификатором, выведенным два раза на строках 4 и 7.

## Дополнительные ссылки {#additional-links}

- [Функция](https://ru.wikipedia.org/wiki/Функция_(программирование))
- [Аргумент](https://ru.wikipedia.org/wiki/Параметр_(программирование))
- [Объявление](https://ru.wikipedia.org/wiki/Объявление_(информатика))
- [Блок кода](https://ru.wikipedia.org/wiki/Блок_(программирование))
- [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости)
- [Повторное использование кода](https://ru.wikipedia.org/wiki/Повторное_использование_кода)
- [Обработка исключений](https://ru.wikipedia.org/wiki/Обработка_исключений)
- [Соглашения об именах (программирование)](https://ru.wikipedia.org/wiki/Соглашения_об_именах_(программирование))
