---
sidebar_position: 5
---

import CodeBlock from '@theme/CodeBlock';
import functions_beginning_1 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_1.py';
import functions_beginning_2 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_2.py';
import functions_beginning_3 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_3.py';
import functions_beginning_4 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_4.py';
import functions_beginning_5 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_5.py';
import functions_beginning_6 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_6.py';
import functions_beginning_7 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_7.py';
import functions_beginning_8 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_8.py';
import functions_beginning_9 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_9.py';
import functions_beginning_10 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_10.py';
import functions_beginning_11 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_11.py';
import functions_beginning_12 from '!!raw-loader!/static/examples/python-language/functions-beginning/functions_beginning_12.py';

# Функции. Начало

## Что такое функция {#what-is-a-function}

В секции **[Переменные и объекты](/docs/python-language/variables-and-objects)** было дано определение функции и аргументов.

**Функция** в Python — именованный (имеющий название) объект, содержащий алгоритм (набор действий), выполняющий какое-то действие с объектами, которые передаются в функцию в качестве аргументов. В других языках определения функции отличаются. Наиболее общее определение, подходящее для всех языков программирования: функция — именованный алгоритм.

Из факта, что любая функция в Python — это объект, — следуют некоторые особенности поведения функций в Python. Это обстоятельство будет рассмотрено подробно в главе **Функциональное программирование**.

Функции бывают встроенные и пользовательские. Встроенные функции созданы авторами языка. Пользовательские функции создаются программистами, пишущими на языке.

Встроенные функции содержат наиболее часто используемые алгоритмы, которые нужны практически в каждой программе. Пользовательские функции — это функции, создаваемые для решения частных задач, стоящих перед программистами.

## Для чего нужны функции {#what-are-functions-for}

Если нам нужно, чтобы во время выполнения программы какой-то набор действий был выполнен несколько раз, лучшее решение — создать функцию и записать в неё этот алгоритм. Тогда мы сможем вызывать функцию столько раз, сколько нам нужно, вместо того чтобы каждый раз записывать этот же набор действий в основной программе. Так мы сможем сильно сократить и упростить программу. Принцип вынесения повторяющегося кода в функции называется принципом **повторного использования кода**.

## Объявление функции {#function-declaration}

**Объявление функции** — форма записи пользовательской функции, принятая в языке программирования.

Функция должна иметь заголовок и тело:

```python showLineNumbers
# Объявление функции
def hello():  # Заголовок функции
    pass      # Тело функции
```

**Заголовок функции** — строка, содержащая ключевое слово `def`, пробел, имя функции, круглые скобки и двоеточие. Внутри круглых скобок могут указываться параметры через запятую.

**Ключевые слова** — зарезервированные создателями языка последовательности символов, используемые для обозначения лексем. Программист не должен использовать ключевые слов в качестве названий переменных, функций, классов и методов, так как это вызовет синтаксическую ошибку.

Ключевое слово `def` происходит от английского глагола «define» — «давать определение, определять».

**Тело функции** — это фрагмент кода, в котором содержится алгоритм, выполняемый при вызове функции. Каждая строка тела функции имеет отступ, равный **четырём пробелам**. Тело функции составляет **логический блок**, воспринимаемый интерпретатором как отдельный компонент программы.

Внутри тела функции могут быть другие логические блоки — строки в них тоже выделяются отступами, равными четырём пробелам, и чем глубже вложенность, тем больше отступов. О том, какие это блоки, будет написано в главе **[Управляющие конструкции. Начало](/docs/python-language/compound-statements-beginning)**.

Поскольку в Python применяется позиционное форматирование, функция должна иметь тело, даже если она не содержит никакого алгоритма. Чтобы как-то обозначить тело пустой функции, в Python применяется инструкция `pass` (от английского «pass» — «пропускать»), указывающая интерпретатору, нужно пропустить фрагмент кода на этом уровне вложенности начиная со строки, где встречается инструкция `pass` и ниже до конца фрагмента, находящегося на этом уровне вложенности.

**Уровень вложенности** — это фрагмент кода, каждая строка которого имеет равное количество отступов. Строки, находящиеся на одном уровне вложенности, объединяются в логический **блок кода**. Блоки кода могут быть вложенными один в другой. В этом случае количество отступов на каждом уровне увеличивается на четыре пробела по сравнению с предыдущим уровнем.

## Аргументы и параметры {#arguments-and-parameters}

Функция может выполнять какие-либо действия с объектами, ссылки на которые передаются в функцию и называются аргументами.

**Аргумент** в Python — ссылка на объект, передаваемая в функцию для обработки. Форма записи вызова функции с аргументом: `<функция>(<аргумент>)`.

В других языках определения аргумента отличаются. Наиболее общее определение, подходящее для всех языков программирования: аргумент — данные, передаваемые в программу или подпрограмму для обработки.

Возможность функции принимать аргументы должна быть явно указана в объявлении функции.

Если нужно, чтобы функция принимала аргументы, в заголовке функции в скобках после названия функции записываются названия локальных переменных, называемые параметрами.

**Параметры** — это локальные переменные (именованные ссылки на объекты), объявленные в заголовке функции и доступные в теле функции.

```python showLineNumbers
# Объявление функции с параметром
def hello(name):             # Заголовок функции c параметром name
    print('Привет,', name)   # Тело функции
```

В чём разница между аргументами и параметрами?

Аргументы — это ссылки на объекты, передаваемые при **вызове** функции. Параметры — **локальные** переменные, задаваемые в заголовке функции при **объявлении** функции.

## Примеры функций {#function-examples}

Разберём пример создания пользовательской функции.

<CodeBlock language="python" title="functions_beginning_1.py" showLineNumbers>{functions_beginning_1}</CodeBlock>

В примере 1 на строке 4 объявлена функция `greet()` с параметром `name`.

Алгоритм, содержащийся в теле функции, представлен вызовом встроенной функции `print()` на строке 6.

Тело функции — это строки с 5 по 7. Каждая строка тела функции начинается с отступа, равного четырём пробелам.

Строка 8 не содержит отступов. Окончание блока кода, выделенного отступами, означает окончание алгоритма функции.

Поскольку в Python применяется позиционное форматирование, очень важно правильно расставлять отступы. Нарушение расстановки отступов нарушит порядок выполнения программы, что приведёт либо к ошибке во время запуска, либо к неправильному результату выполнения программы.

Говорят, что алгоритм **инкапсулирован** внутри функции, то есть заключён (скрыт) в теле функции.

На строке 11 выполняется вызов функции `greet()` со ссылкой на объект `друг`, переданной в функцию в качестве аргумента.

В Python принято перед (за исключением случая, когда файл начинается с объявления функции) и после объявления функции и следующим блоком кода оставлять **две пустые строки**. Несоблюдение этого соглашения не помешает интерпретатору правильно определить, где заканчивается тело функции, но соблюдение соглашения считается хорошим тоном, так как облегчает другим программистам чтение Вашей программы.

:::info внимание

Пользовательская функция в Python обязательно должна быть объявлена до её вызова в программе. Иначе интерпретатор возбудит исключение типа `NameError` и выведет сообщение: `NameError: name 'greet' is not defined`.

:::

## Области видимости переменных {#variable-scopes}

<CodeBlock language="python" title="functions_beginning_2.py" showLineNumbers>{functions_beginning_2}</CodeBlock>

Рассмотрим пример 2.

В примере 2 на строке 13 функция `greet()` вызывается с двумя аргументами: `name` и `greeting`. Аргументы передаются строго в том порядке, в котором указаны параметры, объявленные в заголовке функции `greet()` на строке 3. Это **позиционный** способ передачи аргументов в функцию.

**Позиционные аргументы** (от английского «positional arguments») передаются в функцию строго в том порядке, в каком указаны параметры в заголовке функции.

На строке 14 выполняется то же самое, что на строке 13. Разница лишь в том, что на строке 14 аргументы передаются именованным способом.

**Именованные аргументы** (от английского «keyword arguments») могут передаваться в любом порядке, так как именованный способ предполагает явное указание параметров вызываемой функции.

:::info внимание

Глобальные переменные `name` и `greeting`, объявленные на строках 9 и 10 — это переменные, объявленные на нулевом уровне вложенности и доступные в любом месте программы. А локальные переменные `name` и `greeting`, объявленные на строке 3 в качестве параметров функции `greet()` — это переменные, доступ к которым возможен только в теле функции `greet()`. В примере 2 объявлено четыре переменные, а не две, как могло показаться на первый взгляд. В этом примере у глобальных и локальных переменных совпадают только имена, но это разные переменные.

:::

Глобальные переменные находятся в **глобальной области видимости**, то есть доступны в любом месте программы. Локальные переменные находятся в **локальный области видимости** функции `greet()`, то есть доступны в теле этой функции.

В случаях, когда локальные переменные имеют такие же имена, что и глобальные переменные, принято говорить, что локальные переменные «затеняют» глобальные переменные (от английского «to shadow» — «затенять»).

<CodeBlock language="python" title="functions_beginning_3.py" showLineNumbers>{functions_beginning_3}</CodeBlock>

Рассмотрим пример 3.

Пример 3 иллюстрирует тот факт, что параметры функции — это локальные переменные, не имеющие отношения к глобальным переменным.

На строке 3 объявляется функция `greet()`, выводящая строку, состоящую из строк, переданных в аргументах `first` и `second`.

На строке 13 при вызове функции `greet()` именованным способом локальная переменная `first` связывается с объектом, на который ссылается глобальная переменная `greeting`, а локальная переменная  `second` связывается с объектом, на который ссылается глобальная переменная `name`.

## Значения по умолчанию {#default-values}

Параметры функций могут иметь значения по умолчанию.

<CodeBlock language="python" title="functions_beginning_4.py" showLineNumbers>{functions_beginning_4}</CodeBlock>

Рассмотрим пример 4.

В примере 4 аргумент `greeting` имеет значение по умолчанию. Оно равно строке `Привет`.

Если аргумент имеет значение по умолчанию, при вызове функции его можно не указывать, и тогда во время выполнения функции при инициализации этого параметра будет создан объект, литерал которого указан в заголовке функции при объявлении параметра.

На строке 9 видно, как осуществляется вызов функции `greet()`, и в функцию передаётся только ссылка на переменную `name`. При запуске скрипта будет выведено `Привет, друг!`.

Также можно вызвать функцию с указанием всех аргументов. В этом случае вместо значений по умолчанию будут использованы объект, ссылки на которые переданы в функцию во время её вызова.

На строке 10 в качестве аргумента `greeting` в функцию передаётся ссылка на строку `Здравствуй`, и функция выведет `Здравствуй, друг!`.

На строке 11 выполняется то же, что на строке 10, но аргумент `greeting` передаётся именованным способом.

Выше был описан **позиционный** способ передачи аргументов, когда аргументы передаются в функцию строго в том порядке, в каком они объявлены в функции.

:::info внимание

Если мы попытаемся сначала передать хотя бы один аргумент именованным способом, а следующие аргументы — позиционным, как показано на строке 15, интерпретатор Python возбудит исключение типа `SyntaxError` и выедет сообщение: `SyntaxError: positional argument follows keyword argument`.

:::

Отсюда правило — если мы используем позиционный способ передачи аргументов, в инструкции вызова функции все позиционные аргументы должны быть указаны перед первым именованным аргументом.

## Разделитель параметров `*` (все аргументы после него — именованные) {#parameter-separator-asterisk}

Синтаксис Python настолько гибок, что позволяет указывать в заголовках функций, каким способом следует передавать аргументы при их вызове.

<CodeBlock language="python" title="functions_beginning_5.py" showLineNumbers>{functions_beginning_5}</CodeBlock>

Рассмотрим пример 5.

На строке 5 объявлена функция `greet()`. После параметров `name` и `surname` через запятую указан символ `*`, указывающий, что при вызове функции все аргументы, соответствующие параметрам `message` и `mark`, должны быть переданы именованным способом, поскольку параметры `message` и `mark` объявлены после разделителя `*`.

На строке 16 при вызове функции `greet()` первые два аргумента, соответствующие параметрам `name` и `surname`, передаются позиционным способом, аргумент, соответствующий параметру `message`, передаётся именованным способом, а для параметра `mark` используется значение по умолчанию.

Разделитель `*` не накладывает ограничений на способ переда чи аргументов, соответствующих параметрам, объявленным перед ним. Аргументы, соответствующие параметрам `name` и `surname` могут быть переданы любым способом.  На строке 17 все аргументы передаются именованным способом.

Если раскомментировать строку 18 (убрать комментарий в начале строки) и попытаться запустить программу, интерпретатор возбудит исключение типа `TypeError` и выведет сообщение: `TypeError: greet() takes 2 positional arguments but 3 were given`. Это произойдёт, потому что нарушено правило, задаваемое разделителем `*`: функция принимает только два позиционных аргумента, а передаются три.

<CodeBlock language="python" title="functions_beginning_6.py" showLineNumbers>{functions_beginning_6}</CodeBlock>

В примере 6 при вызове функции `greet()` все аргументы должны быть позиционными, так как разделитель `*` стоит в начале списка параметров.

Так как все аргументы функции `greet()` должны быть именованными, при вызове функции они могут быть переданы в любом порядке. Для параметров `message` и `mark` можно не передавать аргументы, поскольку у них есть значения по умолчанию. Это показано на строках 15 — 18.

Однако, если раскомментировать строку 19 и попытаться вызвать функцию с позиционными аргументами, интерпретатор возбудит исключение `TypeError` и выведет сообщение: `TypeError: greet() takes 0 positional arguments but 2 positional arguments (and 1 keyword-only argument) were given`.

## Разделитель параметров `/` (все аргументы перед ним — позиционные) {#parameter-separator-slash}

При объявлении функции можно использовать разделитель `/`, означающий, что все аргументы, соответствующие параметрам, стоящим перед ним, должны быть позиционными.

<CodeBlock language="python" title="functions_beginning_7.py" showLineNumbers>{functions_beginning_7}</CodeBlock>

Рассмотрим пример 7.

На строке 5 объявлена функция `greet()`. В заголовке функции используется разделитель `/`. Функция должна быть вызвана так, что аргументы, соответствующие парамерам `name` и `surname`, должны быть только позиционными, а аргументы `message` и `mark` могут быть как позиционными, так и именованными. Возможные варианты вызова функции `greet()` показаны на строках 16 — 18.

На строке 19 показан неправильный вызов функции `greet()` с передачей именованного аргумента `surname`. Попытка вызвать функцию таким способом возбудит исключение типа `TypeError` с сообщением: `TypeError: greet() got some positional-only arguments passed as keyword arguments: 'surname'`.

## Сочетание разделителей параметров `/` и `*` (аргументы перед `/` — позиционные; аргументы между `/` и `*` — любые; аргументы после `*` — именованные) {#combination-of-parameter-separators}

При объявлении функций можно сочетать разделители `/` и `*`. Тогда при вызове функции:

- все аргументы, стоящие перед символом `/`, должны быть позиционными;
- все аргументы, стоящие после символа `*`, должны быть именованными;
- аргументы, стоящие между символами `/` и `*`, могут быть как позиционными, так и именованными (естественно, позиционные должны стоять перед именованными).

<CodeBlock language="python" title="functions_beginning_8.py" showLineNumbers>{functions_beginning_8}</CodeBlock>

В примере 8 на строке 5 объявлена функция `greet()` с использованием разделителей `/` и `*`.

При вызове функции аргументы, соответствующие параметрам `name` и `surname`, должны быть только позиционными. Аргументы, соответствующие параметрам `message` и `mark`, должны быть только именованными. На строках 16 и 17 показаны варианты вызова функции.

На строках 18 и 19 показано, что будет, если вызвать функцию `greet()`, нарушив правила, заданные при её объявлении.

<CodeBlock language="python" title="functions_beginning_9.py" showLineNumbers>{functions_beginning_9}</CodeBlock>

В примере 9 аргументы, соответствующие параметрам `name` и `surname`, должны быть только позиционными. Аргумент, соответствующий параметру `message`, может быть как позиционным, так и именованным. Аргумент, соответствующий параметру `mark`, должен быть только именованным. На строках 17 — 19 показаны варианты вызова функции.

## Ещё раз про области видимости переменных {#once-again-about-variable-scopes}

Выше говорилось, что глобальные переменные доступны в любом месте программы, а локальные переменные находятся в области видимости функции, в которой они объявлены. Глобальные переменные объявляются в основной программе. Локальные переменные могут быть объявлены как в заголовке функции (и тогда это — параметры), так и в теле функции.

Каким образом можно получить доступ к глобальным переменным внутри функции?

<CodeBlock language="python" title="functions_beginning_10.py" showLineNumbers>{functions_beginning_10}</CodeBlock>

Рассмотрим пример 10.

На строках 37 и 38 объявлены глобальные переменные `a` и `b`.

Функция `test1()` на строке 3 объявлена без параметров. Вызов функции выполняется на строке 40. В теле функции на строке 4 происходит обращение к глобальной переменной `a`.

Функция `test2()` на строке 7 объявлена без параметров. Вызов функции выполняется на строке 41. В теле функции на строке 8 объявлена локальная переменная `a`, не имеющая никакого отношения к глобальной переменной `a`. На строке 9 происходит обращение к локальной переменной `a`. На строке 10 она удаляется.

Функция `test3()` на строке 13 объявлена с параметром `a`. Вызов функции выполняется на строке 42. При вызове в функцию передаётся ссылка на объект, связанный с глобальной переменной `a`. Параметр `a` — это локальная переменная, не имеющая никакого отношения к глобальной переменной `a`. Поэтому в телефункции возможна манипуляция с переменной на строке 14 (увеличение на единицу и вывод). На строке 16 она удаляется.

Функция `test4()` на строке 19 объявлена без параметров. Вызов функции выполняется на строке 43. В теле функции на строке 20 происходит обращение к глобальной переменной `a`. Если раскомментировать инструкцию на строке 21, интерпретатор возбудит исключение типа `UnboundLocalError` и выведет сообщение: `UnboundLocalError: local variable 'a' referenced before assignment`. Исключение будет относиться к строке 20, а не к строке 21.

Почему так происходит? Если раскомментировать инструкцию на строке 21, интерпретатор посчитает переменную `a` локальной, а не глобальной, потому что в теле функции на строке 20 происходит попытка её удалить. То же самое произойдёт, если интерпретатор обнаружит попытку объявить её. Обнаружив, что обращение к переменной происходит до её объявления в теле функции, интерпретатор завершит работу программы ошибкой. Функция `test5()` на строке 44 так и не будет вызвана.

Функция `test5()` на строке 24 объявлена без параметров. Вызов функции выполняется на строке 44. В теле функции на строке 25 объявлена локальная переменная `b`, имеющим такое же имя, как глобальная переменная `b`. На строке 32 происходит обращение к локальной переменной `b`. На строке 16 она удаляется.

Функция `test6()` на строке 30 объявлена с параметром `a`, имеющим такое же имя, как глобальная переменная `a`. Вызов функции с передачей в качестве аргумента глобальной переменной `b` выполняется на строке 45. Параметр `a` — это локальная переменная, не имеющая никакого отношения к глобальной переменной `a`. На строке 32 в теле функции объявлена переменная `b`, ссылающаяся на тот же объект, на который ссылается глобальная переменная `b` и параметр `a`. На строке 32 происходит вывод строкового представления объекта, на который ссылается локальная переменная `b`. На строке 33 локальная переменная `b` удаляется, но объект, на который ссылается глобальная переменная `b`, сохраняется в памяти. Этот объект удаляется из памяти только после вывода строкового представления глобальной переменной на строке 46.

## Особенности функций в Python (любая функция — это объект) {#features-of-functions-in-python}

В Python функцию можно рассматривать как переменную, являющуюся именем объекта, представляющего собой алгоритм.

В Python функцию можно объявлять несколько раз в теле программы. Это отличается от поведения функций в других языках программирования. Например, в PHP повторное объявление функции вызовет фатальную ошибку.

Такое поведение функций в Python — следствие того, что любая функция в Python — объект. Так же, как можно объявить `a = 1`, а затем поменять ссылку на объект инструкцией `a = a + 1`, в Python можно несколько раз объявить функцию, с параметрами или без.

В Python каждый вызов функции будет обращаться к тому объекту, который был инициализирован перед вызовом. Это отличается от поведения функций в других языках. Например, в JavaScript можно два раза объявить функцию с одним названием, но любое обращение вызовет функцию, которая была объявлена последней.

Вторым следствием того факта, что любая функция в Python — это объект, является невозможность вызвать функцию до того, как она была объявлена в теле программы подобно тому, как невозможно обратиться к переменной до её объявления. В других языках, например, в PHP и JavaScript, можно вызвать функцию до её объявления, если функция объявлена в этом же файле.

<CodeBlock language="python" title="functions_beginning_11.py" showLineNumbers>{functions_beginning_11}</CodeBlock>

Рассмотрим пример 11.

На строке 8 объявлена функция `hello()`.

Если раскомментировать вызов функции `hello()` на строке 4, интерпретатор завершит работу программы с исключением типа `NameError` и выведет сообщение `NameError: name 'hello' is not defined`.

На строке 13 происходит вызов функции `hello()`, а на строке 17 повторное объявление функции, но уже с параметром `name`.

На строке 21 происходит повторный вызов функции. Поскольку функция `hello()` объявлена заново и содержит другой алгоритм, результат вызова функции на строке 21 будет отличаться от результата вызова на строке 13.

На строке 22 происходит удаление функции `hello()` из памяти подобно тому, как удаляются переменные.

Если раскомментировать строку 23, содержащую инструкцию вызова уже удалённой функции, и запустить программу, интерпретатор завершит работу с сообщением: `NameError: name 'hello' is not defined` подобно тому, как он бы завершил работу при попытке обратиться к переменной, которая не была объявлена выше в тексте программы.

## Возвращаемые значения (возвращаемые ссылки на объекты) {#return-values}

В секции **[Структура программы](/docs/python-language/program-structure)** мы говорили о том, что любая программа или подпрограмма имеет типичную структуру: ввод, обработку и вывод данных.

Функция — это подпрограмма.

Ввод данных — это параметры.

Обработка данных — это алгоритм, записанный в теле функции.

Вывод данных — это:

- вывод на экран строковых представлений данных через функцию `print()`, вызываемую в теле функции;
- возвращаемые в основную программу ссылки на объекты посредством оператора `return` (от английского «return» — «возвращать»).

В теории языков программирования сложилась терминология, согласно которой функции «возвращают значения». Хотя в официальной документации по Python применяется эта терминология, более корректно говорить, что функции в Python возвращают ссылки на объекты.

<CodeBlock language="python" title="functions_beginning_12.py" showLineNumbers>{functions_beginning_12}</CodeBlock>

Рассмотрим пример 12.

На строке 3 объявлена функция `concatenate()` с параметрами `a` и `b`. Функция возвращает результат сложения или объединения (конкатенации) двух объектов, ссылки на которые получены в качестве параметров.

На строке 37 функция `concatenate()` вызывается с двумя аргументами: `1` и `2`, и результат вычисления записывается в глобальную переменную `result`. На строке 38 выводится строковое представление объекта, на который указывает переменная `result`. Интерпретатор выведет `3`.

На строке 40 функция `concatenate()` вызывается с двумя аргументами: `гипер` и `текст`, и результат вычисления записывается в глобальную переменную `result`. На строке 41 выводится строковое представление объекта, на который указывает переменная `result`. Интерпретатор выведет `гипертекст`.

Поведение оператора `+` зависит от типов объектов, с которыми он выполняет действие. Если это числа — он их складывает если строки — объединяет в одну строку. Объединение строк называется конкатенацией.

:::info внимание

Функция в Python может принимать ссылки на объекты разных типов, и поведение операторов зависит от типов объектов. О встроенных типах данных речь пойдёт в следующих главах.

:::

Функция может возвращать несколько ссылок на объекты. Для этого нужно записать после оператора `return` переменные или литераты объектов через запятую. Можно, но не обязательно заключать их в скобки.

На строке 7 объявлена функция `divide_with_reminder()` с параметрами `a` и `b`. Функция принимает целые и вещественные числа и возвращающая неполное частное и остаток от деления.

На строке 43 функция вызывается с аргументами `7` и `1`, результат вызова функции записывается в глобальные переменные `quotient` и `remainder`. На строке 44 выводятся строковые представления объектов, на которые ссылаются переменные `quotient` и `remainder`.

Функция может возвращать даже несколько ссылок на один и тот же объект. Такое поведение практически не имеет смысла, но это возможно.

На строке 13 объявлена функция `test1()` с параметром `a`, выводящая идентификатор объекта, связанного с параметром `a` и возвращающая ти ссылки на этот объект.

На строке 46 объявлена глобальная переменная `a` ссылающаяся на объект `строка`, и на строке 47 выводится её идентификатор. На строке 49 вызывается функция `test1()` с аргументом `a` и результат записываются в глобальные переменные `b`, `c`, `d`. На строке 50 выводятся идентификаторы переменных  `b`, `c`, `d`.

Выполнив программу, мы увидим, что три раза выводится один тот же идентификатор. То есть функция вернула три ссылки на один и тот же объект.

Оператор `return` завершает работу функции. Если в теле функции на строках, следующих после вызова оператора `return`, объявлены какие-то инструкции, они никогда не будут выполнены.

На строке 18 объявлена функция `test2()`. В теле функции вызов оператора `return` предшествует выводу строкового представления параметра `a`. На строке 53 функция `test2()` вызывается и возвращает константу `None`. Инструкция `print(id(a))`, объявленная после вызова `return` на строке 20 никогда не будет выполнена. Поэтому такой порядок записи инструкций не имеет практического смысла.

## Константа `None`. Возврат значений по умолчанию {#the-none-constant}

В языке Python есть неизменяемый объект `None` (от английского «none» — «ничто»). Объект `None` — константа. Он инициализируется автоматически при запуске интерпретатора.

Если функция не содержит оператор `return`, в результате вызова она возвращает ссылку на объект `None`. Это поведение функции по умолчанию. Поэтому эквивалентны три варианта завершения работы функции: `return None`, `return` и без оператора `return`.

Функции `test3()`, `test4()` и `test5()`, объявленные на строках 23, 28 и 33 ведут себя одинаково. На строках 54, 55, 56 они вызываются и возвращают ссылку на константу `None`.

## Правила именования функций {#function-naming-rules}

В Python названия функций принято записывать латиницей строчными буквами со знаком подчёркивания `_` между словами (последовательностями символов), составляющими название функции.

В названиях функций принято использовать глаголы, отражающими действие с данными.

Если функция состоит из двух слов, обычно первое слово — глагол, второе — существительное. Если слов в названии функции больше, обычно первое слово — глагол, а дальше по смыслу того, что делает функция. Если слова слишком длинные, можно использовать сокращения, но так, чтобы из названия функции было понятно, что она делает.

Примеры названий функций: `handle_data()`, `parse_site()`, `generate_report()`.

## Дополнительные ссылки {#additional-links}

- [Функция](https://ru.wikipedia.org/wiki/Функция_(программирование))
- [Параметр](https://ru.wikipedia.org/wiki/Параметр_(программирование))
- [Повторное использование кода](https://ru.wikipedia.org/wiki/Повторное_использование_кода)
- [Конкатенация](https://ru.wikipedia.org/wiki/Конкатенация)
- [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости)
- [Соглашения об именах (программирование)](https://ru.wikipedia.org/wiki/Соглашения_об_именах_(программирование))
- [Зарезервированное слово](https://ru.wikipedia.org/wiki/Зарезервированное_слово)
- [Лексический анализ](https://ru.wikipedia.org/wiki/Лексический_анализ)
- [Токен (лексический анализ)](https://ru.wikipedia.org/wiki/Токен_(лексический_анализ))
