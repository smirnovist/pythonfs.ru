---
sidebar_position: 5
---

import CodeBlock from '@theme/CodeBlock';
import strings_1 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/strings/strings_1.py';
import strings_2 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/strings/strings_2.py';
import strings_3 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/strings/strings_3.py';
import strings_4 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/strings/strings_4.py';
import strings_5 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/strings/strings_5.py';

# Строки

## Юникод. Общая информация {#unicode-common-information}

По умолчанию предполагается, что программы на Python записываются в файлы с кодировкой UTF-8, реализующей один из способов кодирования кодовых позиций Юникода.

Кодировка может быть явно указана в файле исходным кодом либо на второй строке (сразу за строкой [shebang](https://ru.wikipedia.org/wiki/Шебанг_(Unix))), либо на первой строке (если строка shebang отсутствует).

Ниже приведён пример первых двух строк файла с исходным кодом в кодировке UTF-8. Первая строка — shebang. Вторая строка — указание кодировки.

```python showLineNumbers
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

Такая форма указания кодировки рекомендуется к использованию и распознаётся интерпретатором. Эта форма используется для совместимости с популярным текстовым редактором [Emacs](https://ru.wikipedia.org/wiki/Emacs).

В этом учебнике в файлах с исходным кодом отсутствует явное указание кодировки, поскольку используется кодировка по умолчанию — UTF-8. Обычно имеет смысл явно указывать кодировку только в случаях, если кодировка в файлах с исходным кодом отличается от принятой по умолчанию.

[Юникод](https://www.unicode.org/) — это спецификация, целью которой является перечисление всех символов, используемых в человеческих языках, и присвоение каждому символу его собственного уникального кода. Спецификация Юникода постоянно пересматривается и обновляются, чтобы добавить новые языки и символы.

Стандарт Юникода описывает, как символы представлены кодовыми позициями (от английского «code points»). Значение кодовой позиции — это целое число в диапазоне от `0` до `0x10FFFF` (1 114 111 в десятичной системе счисления). В стандарте кодовая позиция записывается с использованием обозначения `U+265E` для обозначения символа со значением `0x265e` (9 822 в десятичной системе счисления).

Стандарт Юникода содержит множество таблиц, в которых перечислены кодовые позиции и соответствующие им символы. Кодовые позиции в базе данных Юникода отнесены к группам. Группы включают в себя кодовые позиции, объединённые по смыслу соответствующих символов.

В шрифтах, поддерживающих Юникод, кодовые позиции соотносятся с [глифами](https://ru.wikipedia.org/wiki/Глиф), которые выводятся на экран для отображения соответствующих кодовых точек, закодированных в кодировках Юникода. За отображение глифов отвечает программное обеспечение, реализующее визуализацию шрифтов в графическом интерфейсе пользователя или терминале.

Стандарт Юникода содержит несколько разных способов представления кодовых позиций (от английского «Unicode transformation format», сокращённо UTF). Эти способы называются кодировками. Наиболее широко используемая кодировка — UTF-8 (от английского «Unicode Transformation Format, 8-bit»). Она позволяет кодировать символы с переменным количеством байтов и имеет обратную совместимость с более ранними однобайтовыми кодировками ASCII и ISO 8859-1 (Latin-1), что обеспечило ей наиболее широкую популярность. Каждый символ в кодировке UTF-8 закодирован последовательностью длиной от одного до четырёх байтов.

Кодировки ASCII и ISO 8859-1 содержат коды символов, каждый их которых можно представить последовательностью длиной в один байт. Соответственно, количество символов, представленных в этих кодировках, не может превышать 256 (2<sup>8</sup>). Вариант кодировки ASCII, не содержащий национальных символов, называется «US-ASCII» или «international reference version» и содержит первые 128 символов, общие для всех национальных однобайтовых кодировок на основе ASCII. Кодировка ISO 8859-1 (Latin-1) содержит 256 символов и обратно совместима с US-ASCII. Первые 128 символов кодировки ISO 8859-1 являются символами кодировки US-ASCII. Кодировка UTF-8, в свою очередь, обратно совместима с ISO 8859-1, и первые 256 символов кодировки UTF-8 являются символами кодировки ISO 8859-1.

Обратная совместимость кодировки UTF-8 обеспечивает возможность использовать программное обеспечение, предназначенное для работы с данными, представленными в однобайтовых кодировках, для работы с данными в кодировке UTF-8, если эти данные не содержат символов, закодированных последовательностями длиной более одного байта.

Другие способы кодирования символов Юникода — UTF-16 и UTF-32 — не столь популярны из-за отсутствия обратной совместимости с кодировками ASCII и ISO 8859-1 и проблемами, возникающими вследствие того, что эти кодировки предполагают варианты кодирования с разным порядком следования байтов.

Более подробно о стандарте Юникода и кодировках UTF-8, UTF-16, UTF-32, ASCII, ISO 8859-1 можно почитать на Википедии и на сайте [unicode.org](https://www.unicode.org/). Нужные ссылки представлены внизу в блоке «Дополнительные ссылки».

В стандартной библиотеке Python есть модуль [`unicodedata`](https://docs.python.org/3/library/unicodedata.html) для работы с базой данных Юникода. Он содержит подробную информацию о кодовых позициях.

Если программа записана в кодировке UTF-8, явное указание кодировки не требуется, так как UTF-8 — кодировка по умолчанию. Также не слудует добавлять к файлам в кодировке UTF-8 [Byte Order Mark](https://ru.wikipedia.org/wiki/Маркер_последовательности_байтов) (сокращённо BOM), так как для UTF-8 указание BOM необязательно.

Явное указание кодировки относится только к файлу, в котором она указана. Если программа состоит из нескольких файлов, и программист явно указывает кодировку, кодировку нужно указывать во всех файлах программы.

## Строки. Общая информация. Литералы строк {#strings-common-information-string-literals}

Строка (`str`) — это **неизменяемая** последовательность (то есть индексируемая коллекция) символов Юникода. Строки в Python применяются для обработки текстовых данных.

Строки поддерживают все операции, общие для последовательностей. Кроме этого, класс `str` имеет богатый набор дополнительных методов. Все эти методы с примерами использования перечислены ниже.

Также для работы со строками в стандартной библиотеке имеется большой набор [модулей для работы с текстом](https://docs.python.org/3/library/text.html). Наиболее широко используемыми в этом наборе являются модули [`string`](https://docs.python.org/3/library/string.html) и [`re`](https://docs.python.org/3/library/re.html) (модуль для работы с регулярными выражениями).

Литералы строк:

- одинарные кавычки: `'строка в одинарных кавычках позволяет вставлять "двойные" кавычки внутри строки'`;
- двойные кавычки: `"строка в двойных кавычках позволяет вставлять 'одинарные' кавычки внутри строки"`;
- идущие три раза подряд одинарные кавычки: `'''одна или несколько строк в тройных одинарных кавычках позволяют вставлять 'одинарные' и "двойные" кавычки внутри строки'''`;
- идущие три раза подряд двойных кавычки: `"""одна или несколько строк в тройных двойных кавычках позволяют вставлять 'одинарные' и "двойные" кавычки внутри строки"""`.

Строки в идущих три раза подряд одинарных или двойных кавычках могут включать в себя несколько строк — все символы перехода на новую строку будут включены в строковый литерал.

Если несколько строковых литералов записаны подряд, и между ними имеются только пробелы, эти литералы будут неявно объединены в один строковый литерал. Например:

```python showLineNumbers
>>> a = 'пара' 'граф'
>>> a
'параграф'
>>> b = 'параграф'
>>> b
'параграф'
>>> a == b
True
>>> a is b
False
```

Строковые литералы могут иметь префиксы:

- `'r'`, `'R'` (взаимозаменяемые) — признак «сырого» литерала (от английского «raw» — «сырой») — отменяет экранирование управляющих последовательностей;
- `'f'`, `'F'` (взаимозаменяемые) — признак форматированного литерала — указывает интерпретатору на то, что к литералу нужно применять правила форматирования;
- `'u'`, `'U'` (взаимозаменяемые) — признак того, что литерал закодирован в кодировке Юникода — устаревший префикс, добавленный для упрощения [портирования](https://ru.wikipedia.org/wiki/Портирование_программного_обеспечения) кода, изначально написанного на Python 2, и не несущий в Python 3 смысловой нагрузки; вероятно, будет через какое-то время удалён.

Префиксы `'r'`, `'R'` и `'f'`, `'F'` могут быть скомбинированы, и тогда к литералу применяются правила, задаваемые обоими префиксами.

Комбинации `'fr'`, `'Fr'`, `'fR'`, `'FR'`, `'rf'`, `'rF'`, `'Rf'`, `'RF'` означают одно и то же — «сырой» форматированный литерал.

Префикс `'u'`, `'U'` не может быть скомбинирован с другими префиксами. Для программ, изначально написанных на Python 3, использовать его не имеет смысла.

Поскольку в Python не существует отдельного символьного типа (типа данных для отдельных символов), при обращении к элементам строк по индексам возвращаются ссылки на строки, каждая из которых состоит из одного символа. Поэтому, в отличие от всех других последовательностей, для непустой строки `s` выражение `s[0]` вернёт то же, что срез из одного элемента `s[0:1]`:

```python showLineNumbers
>>> s = 'абвгде'
>>> s[0]
'а'
>>> s[0:1]
'а'
```

Это происходит потому, что срез всегда является объектом того же типа, что исходная последовательность. Следовательно, срез строки, содержащий один символ — это строка, равная (но не обязательно идентичная) элементу со смещением, равным началу среза.

В целях оптимизации набор строковых символов, входящих в константу [`string.printable`](https://docs.python.org/3/library/string.html#string.printable), предварительно загружается в оперативную память при запуске интерпретатора. Это цифры, буквы основной латиницы, пробельные символы. Все они являются однобайтовыми (то есть для их кодирования достаточно одного байта) и входят в кодировку ASCII (и, соответственно, в Юникод). Поэтому каждый элемент из этой последовательности идентичен срезу, состоящему из одного элемента и имеющему начальное значение, равное смещению этого элемента. Код, приведённый ниже, выведет `True` на каждой итерации, если его выполнить на эталонной реализации интерпретатора CPython. Этот пример выполняется в интерактивном режиме, но если записать его в файл и выполнить, результат будет тот же.

```python showLineNumbers
>>> import string
>>> s = string.printable
>>> print(repr(s))
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
>>> for i, e in enumerate(s):
...     print(e is s[i:i + 1])
...
```

Символы русского алфавита в кодировке UTF-8 кодируются последовательностями длиной в два байта и не загружаются предварительно в оперативную память при запуске интерпретатора. Поэтому код, приведённый ниже, выведет `False` на каждой итерации. Этот пример выполняется в интерактивном режиме, но если записать его в файл и выполнить, результат будет тот же.

```python showLineNumbers
>>> s = 'абвгдеёжзиклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'
>>> for i, e in enumerate(s):
...     print(e is s[i:i + 1])
...
```

Поэтому во избежание ошибок сравнение строк следует делать по значению (оператор `==`), а не по идентичности (оператор `is`). Если сравнивать две одинаковые строки, оператор `==` гарантированно вернёт `True`, и не важно, одинаковые у них идентификаторы или нет.

Если не указан префикс `'r'` или `'R'`, управляющие последовательности в строковых и байтовых литералах интерпретируются в соответствии с правилами, аналогичными тем, которые используются в стандарте языка C.

### Таблица 1. Управляющие последовательности, распознаваемые в строковых и байтовых литералах {#table-1-escape-sequences-recognized-in-string-and-byte-literals}

| Управляющая последовательность | Описание | Примечания |
|--------------------------------|----------|------------|
| `\newline`   | Обратный слеш и новая строка игнорируются | 1 |
| `\\`         | Обратный слеш (`\`) | |
| `\'`         | Одинарная кавычка (`'`) | |
| `\"`         | Двойная кавычка (`"`) | |
| `\a`         | Звуковой сигнал (ASCII BEL) | |
| `\b`         | Возврат на шаг (ASCII BS) | |
| `\f`         | Новая страница (ASCII FF) | |
| `\n`         | Перевод строки (ASCII LF) | |
| `\r`         | Возврат каретки (ASCII CR) | |
| `\t`         | ASCII Horizontal Tab (ASCII TAB) | |
| `\v`         | ASCII Vertical Tab (ASCII VT) | |
| `\ooo`       | Символ с восьмеричным значением *ooo* | 2, 4 |
| `\xhh`       | Символ с шестнадцатеричным значением *hh* | 3, 4 |

### Таблица 2. Управляющие последовательности, распознаваемые только в строковых литералах {#table-2-escape-sequences-only-recognized-in-string-literals}

| Управляющая последовательность | Описание | Примечания |
|--------------------------------|----------|------------|
| `\N{name}`   | Символ с названием *name* в базе данных Юникода | 5 |
| `\uxxxx`     | Символ с 16-битным шестнадцатеричным значением *xxxx* | 6 |
| `\Uxxxxxxxx` | Символ с 32-битным шестнадцатеричным значением *xxxxxxxx* | 7 |

### Примечания к таблицам 1 и 2 {#notes-to-table-1-and-table-2}

1. Выражение `\newline` означает явное объединение двух физических строк в одну логическую строку. Обратный слеш, стоящий перед непечатаемым символом перевода строки (имеющим код 10) подавляет перевод на другую строку:

    ```python showLineNumbers
    >>> s = 'a\
    ... b'
    >>> s
    'ab'
    ```

    Сравните репрезентацию строкового объекта, объявленного через многострочный литерал с переводом строки. В полученном объекте имеется управляющая последовательность `'\n'`. В интерактивном режиме интерпретатор выводит представление объекта, которое может быть выведено также при помощи функции `repr()`:

    ```python showLineNumbers
    >>> s = '''a
    ... b'''
    >>> s
    'a\nb'
    ```

    Если вывести полученный объект при помощи функции `print()`, интерпретатор выведет две строки:

    ```python showLineNumbers
    >>> print(s)
    a
    b
    ```

2. Как и в стандарте языка C, допускается до трёх восьмеричных цифр.
3. В отличие от стандарта языка C требуется ровно две шестнадцатеричные цифры.
4. В байтовом литерале шестнадцатеричные и восьмеричные управляющие символы обозначают байт с заданным значением. В строковом литерале эти управляющие символы обозначают символ Юникода с заданным значением.
5. Поддержка [псевдонимов имён](https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt) Юникода добавлена в Python 3.3.
6. Требуется ровно четыре шестнадцатеричных цифры.
7. Таким способом можно закодировать любой символ Юникода. Требуется ровно восемь шестнадцатеричных цифр.

:::info внимание

Шестнадцатеричное представление числа похоже на представление числа в виде строки вида `'\uxxxx'` (для кодовых позиций, которые могут быть закодированы последовательностями длиной, не превышающей два байта) и `\Uxxxxxxxx` (для любых кодовых позиций). В управляющих последовательностях Юникода префиксы `'0x'` заменены префиксами `'\u'` или `'\U'` и добавлены ведущие нули, недостающих до представлений `'\uxxxx'` или `\Uxxxxxxxx`. Любой символ может быть закодирован с добавлением ведущих нулей, недостающих до представления `\Uxxxxxxxx`, если взять номер его позиции в шестнадцатеричной системе счисления, отбросить префикс `'0x'`, добавить префикс `'\U'` и нужное количество ведущих нулей.

:::

Например, берём латинскую букву `'a'` с кодом `97` и представляем в виде управляющих последовательностей Юникода:

```python showLineNumbers
>>> ord('a')
97
>>> hex(ord('a'))
'0x61'
>>> '\u0061'
'a'
>>> '\U00000061'
'a'
```

Модуль [`unicodedata`](https://docs.python.org/3/library/unicodedata.html) для работы с базой данных Юникода содержит подробную информацию о кодовых позициях.

Например, мы можем узнать информацию о латинской букве `'a'`:

```python showLineNumbers
>>> import unicodedata as u
>>> u.name('a')
'LATIN SMALL LETTER A'
>>> u.lookup('LATIN SMALL LETTER A')
'a'
>>> u.category('a')
'Ll'
```

Категория «Ll» означает «Letters lowercase» (буквы в нижнем регистре).

Модуль `unicodedata` содержит полезный метод [`unicodedata.normalize(form, unistr)`](https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize), позволяющий выполнять нормализацию строку Юникода, переданную через аргумент `unistr`, используя схему (форму), переданную через аргумент `form`. Это может быть полезно для сортировки строк согласно правилам, принятых в национальных алфавитах (правила следования одних и тех же символов за другими различаются в разных алфавитах различаются).

<CodeBlock language="python" title="strings_1.py" showLineNumbers>{strings_1}</CodeBlock>

В примере 1 строка 1 — это shebang, а строка 2 — комментарий с явным указанием кодировки файла — UTF-8.

На строках с 5 по 8 приведены примеры объявления строк через литералы.

:::info внимание

Если литерал заключён в одинарные кавычки, внутри строки можно использовать двойные кавычки без экранирования, но если вставить одинарные кавычки, на этапе разбора кода будет возбуждено исключение типа `SyntaxError` с сообщением `SyntaxError: invalid syntax`, и интерпретатор не начнёт выполнение программы.

:::

На строках с 17 по 19 приведены примеры объявления строк с экранированием символов при помощи обратного слеша.

На строке 27 приведён пример объявления строки через литерал с управляющей последовательностью `'\n'`. Если вывести объект `s9` с помощью функции `print()`, будет выведено две строки. Если вывести представление объекта, которое возвращает функция `repr()`, будет выведено представление с управляющей последовательностью `\n`.

Функция `print()` выводит результат вызова служебного (магического) метода `object.__str__()`, возвращающего строковое представление объекта, предназначенное для конечного пользователя программы. Функция `repr()` возвращает результат вызова служебного (магического) метода `object.__repr__()`, возвращающего, строковое представление программы, отражающее внутреннее представление объекта, предназначенное для программиста.

Таким образом, выражение `print(s8)` на строке 28 эквивалентно выражению `print(s8.__str__())`, а выражение `print(repr(s8))` на строке 33 эквивалентно выражению `print(s8.__repr__())`.

На строке 38 приводится «сырая» строка с управляющей последовательностью, представляющей символ перевода строки. Управляющая последовательность не обрабатывается.

На строке 39 эта «сырая» строка выводится с помощью функции `print()`, а на строке 43 выводится строковое преставление объекта `s9`, возвращаемое функцией `repr()`.

:::info внимание

Функция `repr()` добавляет дополнительные ведущие слеши к управляющим последовательностям «сырых» строк, экранируя слеши.

:::

На строках с 48 по 51 показаны способы записи символов Юникода в литералах строк. На строке 54 продемонстрировано, что интерпретатор распознаёт управляющие последовательности, следующие друг за другом в литералах строк.

На строке 57 выводится в десятичной системе счисления номер позиции в базе данных Юникода, заданной по имени.

На строке 58 выводится символ, соответствующий номеру позиции в базе данных Юникода, заданной в десятичной системе счисления.

На строке 59 выводится в шестнадцатеричной системе счисления номер позиции в базе данных Юникода, заданной в десятичной системе счисления.

На строке 62 приведён пример объединения (конкатенации) строк при помощи оператора `+`.

На строке 68 приведена большая строка, которая может быть разбита на несколько физических строк для удобства работы с ней.

На строках по 74 по 100 приведены разные способы объединения физических строк в одну логическую строку. Первый способ на строке 74 является наиболее наглядным и рекомендуется к использованию. Второй способ на строке 87 объединяет несколько строк, заданных через литералы, в одну. Этот способ не рекомендуется использовать, так как он работает медленно. В третьем способе на строке 100 используется неявное объединение нескольких строк в одну. Этот способ не рекомендуется использовать из-за неявного объединения, которого следует избегать из-за возможных ошибок.

На строке 112 демонстрируется, что переменные, объявленные на строках 68, 74, 87 и 100, в целях оптимизации ссылаются на одни и тот же строковый объект (оптимизация применяется интерпретатором, поскольку строковые объекты являются неизменяемыми в Python).

На строке 115 приводится литерал строки, имеющей символы переноса на новую строку, заключённой в идущие три раза подряд кавычки. В данном случае это двойные кавычки, но могут быть и одинарные.

На строке 122 строка выводится на экран при помощи функции `print()`. На строке 132 эта же выводится представление строки, возвращаемое функцией `repr()`. Символы новой строки представлены в виде управляющих последовательностей `'\n'`.

## «Подводные камни» при работе со строками. Управляющие последовательности и «сырые» литералы строк {#pitfalls-when-working-with-strings-escape-sequences-and-raw-string-literals}

При работе со строками нужно учитывать, что не экранированные обратные слеши интерпретируются как ведущие символы управляющих последовательностей. Если интерпретатор сумеет распознать управляющие последовательности, он применит к строке правила обработки управляющих последовательностей. В противном случае он возбудит исключение типа `SyntaxError` при обнаружении первой управляющей последовательности, которую невозможно обработать, на этапе синтаксического анализа литерала строки слева направо.

<CodeBlock language="python" title="strings_2.py" showLineNumbers>{strings_2}</CodeBlock>

Если раскомментировать строку 3 в примере 2, будет возбуждено исключение типа `SyntaxError` с сообщением `SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape`. Это сообщение означает, что при анализе литерала строки слева направо интерпретатор обнаружил управляющую последовательность `'\U'` в названии каталога `'C:\Users'` и попытался применить к ней правила обработки кодовых позиций Юникода, закодированных 32-битным шестнадцатеричными представлениями, что завершилось ошибкой.

Если экранировать обратный слеш в названии каталога `'C:\Users'`, интерпретатор не будет рассматривать подстроку `'\U'` как управляющую последовательность и выполнит инструкцию, как показано на строке 7. Но на этом проблемы не заканчиваются: интерпретатор обнаружит в названии каталога `'\new'` управляющую последовательность `'\n'` (перевод строки) и обработает её. Остальные подстроки — `'\s'` в названии каталога `'\smirn'`, `'\D'` в названии каталога `'\Documents'` и `'\p'` в названии файла `'\program.py'` — интерпретатор проигнорирует, так как они не являются распознаваемыми управляющими последовательностями.

Чтобы избежать неожиданного поведения программ, связанного с обработкой строк, нужно либо экранировать все обратные слеши в литералах строк, либо использовать «сырые» литералы строк с префиксом `'r'` (или `'R'`, что одно и то же), как показано на строках 13 и 18.

Строки также могут быть созданы из других объектов с помощью встроенной функции [`str()`](https://docs.python.org/3/library/functions.html#func-str).

### `class str(object='')` {#class-str-object}
### `class str(object=b'', encoding='utf-8', errors='strict')` {#class-str-object-b-encoding-utf-8-errors-strict}

Функция-[конструктор](https://ru.wikipedia.org/wiki/Конструктор_(объектно-ориентированное_программирование)) `str()` возвращает строковую версию объекта, переданного через аргумент `object`. Если аргумент `object` не указан, возвращает пустую строку. Если же аргумент `object` указан, поведение функции `str()` зависит от того, указаны ли аргументы `encoding` (кодировка) и `errors` (ошибки).

Если при вызове функции `str()` не указан ни аргумент `encoding`, ни аргумент `errors`, функция возвращает результат вызова служебного (магического) метода [`object.__str__()`](https://docs.python.org/3/reference/datamodel.html#object.__str__), который возвращает строковое представление объекта `object`. Для строковых объектов этот метод возвщарает ссылку на сам объект `object`. Если у объекта `object` нет метода `__str__()`, тогда функция `str()` возвращает результат вызова функции [`repr(object)`](https://docs.python.org/3/library/functions.html#repr). Вызов функции `repr(object)`, в свою очередь, пытается вернуть результат вызова метода [`object.__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__]), если он есть у объекта `object`.

Если при вызове функции `str()` указан хотя бы один из аргументов `encoding` и `errors`, объект `object` должен быть байтоподобным объектом.

Под байтоподобными объектами (объектами, подобными байтам) подразумеваются объекты, поддерживающие протокол буфера. К байтоподобным объектам относятся объекты `bytes`, `bytearray` и [`array.array`](https://docs.python.org/3/library/array.html#array.array), а также объекты `memoryview`. Байтоподобные объекты могут использоваться для различных операций с двоичными данными, включая сжатие, сохранение в двоичный файл и отправку через сокет.

В случае, если объект `object` является объектом типа `bytes` или `bytearray`, результат вызова функции `str(bytes, encoding, errors)` эквивалентен результату вызова метода `bytes.decode(encoding, errors)`, а результат вызова функции `str(bytearray, encoding, errors)` — результату вызова метода `bytearray.decode(encoding, errors)`. В противном случае при вызове функции `str(bytes, encoding, errors)` на основе байтоподобного объекта автоматически создаётся объект типа `bytes`, затем у полученного объекта вызывается метод `bytes.decode(encoding, errors)`, результат выполнения которого возвращается в программу.

Вызов функции `str()` с байтоподобным объектом `object` без указания аргументов `encoding` или `errors` возвращает результат вызова метода `object.__str__()` в случае наличия метода `__str__()` у объекта, а в случае его отсутствия — вызова `repr(object)`, как было указано указано выше.

Пример вызова функции `str()` с объектом типа `bytes` без указания аргументов `encoding` и `errors`:

```python showLineNumbers
>>> str(b'Zoot!')
"b'Zoot!'"
```

:::info внимание

Различие строковых представлений объекта, возвращаемых служебными методами `object.__str__()` и `object.__repr__()` заключается в том, что метод `object.__str__()` возвращает представление объекта, предназначенное для вывода на экран и удобное для восприятия человека, а метод `object.__repr__()` возвращает репрезентацию (представление) объекта, отражающую его внутреннее представление. Функция `print()` выводит результат вызова метода `object.__str__()`, так как это представление предназначено для конечного пользователя программы. Интерактивный режим REPL выводит `object.__repr__()`, так как это представление более наглядно демонстрирует программисту характеристики объекта:

:::

```python showLineNumbers
>>> a = 'привет,\nмир!'
>>> print(a)
привет,
мир!
>>> print(a.__str__())
привет,
мир!
>>> a
'привет,\nмир!'
>>> print(a.__repr__())
'привет,\nмир!'
>>> a.__str__()
'привет,\nмир!'
>>> a.__repr__()
"'привет,\\nмир!'"
```

<CodeBlock language="python" title="strings_3.py" showLineNumbers>{strings_3}</CodeBlock>

Пример 3 иллюстрирует создание строковых объектов на основе объектов разных типов при помощи функции `str()`. Созданные объекты выводятся в двух вариантах для сравнения: строковые представления объектов, предназначенные для конечного пользователя, и представления объектов, возвращённые функцией `repr()`.

На строках 3, 6 и 9 создаются объекты типа `str` на основе числовых объектов (константа `True` — тоже целое число тип `bool`).

На строках 12 и 15 создаются объекты типа `str` на основе констант `None` и `NotImplemented`.

На строке 18 создаётся строка на основе кортежа.

На строке 21 создаётся строка на основе списка.

На строках 24, 28 и 35 создаются строковые объекты на основе объектов типа `bytes`. Как видно в примерах на строках 28 и 35, функция `str()` возвращает разные результаты на основе одного и того же байтоподобного объекта, если не указать или указать аргумент `encoding`.

На строке 39 создаётся объект типа `bytes` через вызов метода `encode()` строкового объекта, заданного через литерал.

На строке 46 создаётся строковый объект через вызов метода `b1.decode()` байтового объекта, что эквивалентно выполнению инструкции `str(b1, 'utf-8')`.

На строках 49 и 52 приводятся примеры создания строковых объектов на основе объекта-функции `print` и типа данных `int`.

## Поддержка строками операций, общих для всех последовательностей {#string-support-for-operations-common-to-all-sequences}

Строки поддерживают операции, общие для всех последовательностей.

<CodeBlock language="python" title="strings_4.py" showLineNumbers>{strings_4}</CodeBlock>

В пример 4 иллюстрирует поддержку строковыми объектами операций, общих для всех последовательностей.

На строках с 4 по 6 приводятся примеры арифметических операций со строками: конкатенация (оператор `+`) и повторение (оператор `*`). Операции выполняются в соответствии с приоритетами выполнения операций, перечисленными в главе **[Операторы](/docs/python-language/operators)**.

На строках с 9 по 12 приводятся примеры использования операторов сравнения.

На строках 16 и 17 — примеры операторов принадлежности.

На строках 20 и 21 — обращение к элементам строк по индексам.

На строках с 24 по 27 — взятие срезов у строк.

На строках с 30 по 32 — вызов встроенных функций `len()`, `min` и `max()` со строками.

На строках 35 и 36 — вызов у строк методов `str.index()` и `str.count()`, общих для всех последовательностей.

На строках с 39 по 42 приводится пример работы со строками в цикле `for`.

:::info внимание

Конкатенация строк в цикле неэффективна в плане потребления памяти и скорости работы и не рекомендуется для работы с длинными строками. Поскольку строки являются неизменяемыми последовательностями, на каждой итерации цикла создаётся новый объект и связывается с существующей переменной. Чем больше итераций цикла, тем больше объектов будет создано и затем уничтожено.

:::

На строке 41 на каждой итерации будет создан новый объект, полученный путём конкатенации с предыдущим объектом `a`, и переменная `a` будет связана с этим объектом, а предыдущий разыменованный объект будет уничтожен во время сборки мусора.

Вместо этого можно воспользоваться встроенным оптимизированным методом `str.join()`, как показано на строке 45.

Дополнительные методы строковых объектов приведены ниже.

## Методы строк {#string-methods}

**Примечание.** Здесь и далее строковые литералы в тексте учебника заключены в кавычки (одинарные или двойные), чтобы подчеркнуть их отличие от других элементов программ — операторов, переменных, названий функций и так далее.

### `str.capitalize()` {#str-capitalize}

Возвращает копию строки, где первая буква будет заглавной, а остальные — строчными. Если первая буква — диграф, то к верхнему регистру будет приведён только первый символ диграфа.

```python showLineNumbers
>>> 'привет'.capitalize()
'Привет'
```

### `str.casefold()` {#str-casefold}

Возвращает копию строки, где все символы будут представлены в нижнем регистре. Это позволяет сравнивать строки, где символы изначально представлены в разных регистрах.

Результат вызова метода `str.casefold()` похож на результат вызова метода `str. lower()` с той разницей, что `str.casefold()` более агрессивен, поскольку предназначен для удаления всех различий в строке. Например, немецкая строчная буква `'ß'` эквивалентна `'ss'`. Поскольку она и так представлена в нижнем регистре, метод `str.lower()` оставит `'ß'` как есть, в то время как метод `str.casefold()` преобразует её в `'ss'`.

Алгоритм, в соответствии с которым работает метод `str.casefold()`, представлен в разделе 3.13 стандарта Юникода.

```python showLineNumbers
>>> 'Привет'.casefold()
'привет'
```

### `str.center(width[, fillchar])` {#str-center-width-fillchar}

Возвращает строку указанной ширины (обязательный аргумент `width`), выровненную по центру с использованием пробелов, если при вызове метода для аргумента `fillchar` использовано значение по умолчанию. Если при вызове передан необязательный аргумент `fillchar`, вместо пробелов слева и справа строка заполняется указанным символом. Если аргумент `width` меньше или равен длине строки (`len(s)`), возвращается ссылка на исходную строку.

:::info внимание

В описании метода `str.center(width[, fillchar])` параметр `fillchar` и запятая перед ним записаны в квадратных скобках. Эта форма записи означает, что при вызове метода аргумент `fillchar` не является обязательным.

:::

```python showLineNumbers
>>> 'привет'.center(20)
'       привет       '
>>> 'привет'.center(20, '+')
'+++++++привет+++++++'
```

### `str.count(sub[, start[, end]])` {#str-count-sub-start-end}

Возвращает количество не накладывающихся друг на друга вхождений подстроки `sub`. Необязательные аргументы `start` и `end` интерпретируются как границы среза, в пределах которого ведётся поиск.

```python showLineNumbers
>>> 'ананас'.count('ана')
1
>>> 'ананас'.count('на')
2
>>> 'ананас'.count('на', 1, 4)
1
>>> 'ананас'.count('на', 1, 5)
2
```

### `str.encode(encoding="utf-8", errors="strict")` {#str-encode-encoding-utf-8-errors-strict}

Возвращает объект типа `bytes`, созданный на основе исходной строки. Необязательный аргумент `encoding` (значение по умолчанию — `'utf-8'`) — строка с указанием кодировки исходной строки. Необязательный аргумент `errors` (значение по умолчанию — `'strict'`) указывает на то, что при возникновении ошибок распознаванием кодировки возбуждается исключение типа `UnicodeError`. Другие возможные значения этого аргумента перечислены в разделе [Error Handlers](https://docs.python.org/3/library/codecs.html#error-handlers) модуля `codecs` стандартной библиотеки.

Список доступных кодировок указан в официальной документации Python в разделе [Standard Encodings](https://docs.python.org/3/library/codecs.html#standard-encodings).

 Пример ниже позволяет сравнить поведение метода `str.encode()` и встроенной функции `bytes()`, создающей объект типа `bytes` на основе неизменяемой последовательности или целого числа.

```python showLineNumbers
>>> 'hello'.encode()
b'hello'
>>> 'привет'.encode()
b'\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
>>> bytes('hello', 'utf-8')
b'hello'
>>> bytes('привет', 'utf-8')
b'\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
```

### `str.endswith(suffix[, start[, end]])` {#str-endswith-suffix-start-end}

Возвращает `True`, если строка заканчивается подстрокой, указанной в аргументе `suffix`. В противном случае возвращает `False`. Аргумент `suffix` также может быть кортежем, состоящим из строк — в этом случае сопоставление ведётся с каждым элементом кортежа, и если хотя бы один элемент кортежа совпадает с концом строки, возвращается `True`. Необязательные аргументы `start` и `end` интерпретируются как границы среза, в пределах которого ведётся поиск.

```python showLineNumbers
>>> 'привет'.endswith('вет')
True
'привет'.endswith('нет')
False
>>> 'привет'.endswith(('вет', 'нет'))
True
>>> 'привет'.endswith('ет', 4)
True
>>> 'привет'.endswith('ве')
False
>>> 'привет'.endswith('ве', 0, 5)
True
```

### `str.expandtabs(tabsize=8)` {#str-expandtabs-tabsize-8}

Возвращает копию строки, где все символы табуляции заменены пробелами. Необязательный аргумент `tabsize` указывает ширину табуляции (значение по умолчанию равно `8`). Символы табуляции обрабатываются так, как если бы это были столбцы таблицы, разделённые символом табуляции. Символы табуляции заменяются пробелами. Количество пробелов, вставляемых вместо символов табуляции, рассчитывается исходя из ширины столбца, указанном в аргументе `tabsize`. Количество пробелов каждого столбца равно `tabsize` минус количество символов текущего столбца. Расчёт ведётся исходя их того, чтобы все полученные столбцы были по возможности одинаковой ширины. Если текущий столбец состоит из непробельных символов, он не разрывается на столбцы, равные `tabsize`.

```python showLineNumbers
>>> '01\t012\t0123\t01234'.expandtabs()
'01      012     0123    01234'
>>> '01\t012\t0123\t01234'.expandtabs(4)
'01  012 0123    01234'
```

### `str.find(sub[, start[, end]])` {#str-find-sub-start-end}

Возвращает индекс первого найденного вхождения подстроки `sub` в исходной строке. Если подстрока не найдена, возвращает `-1`. Необязательные аргументы `start` и `end` интерпретируются как границы среза, в пределах которого ведётся поиск.

```python showLineNumbers
>>> 'ананас'.find('а')
0
>>> 'ананас'.find('на')
1
>>> 'ананас'.find('б')
-1
```

Метод `str.find()` используется, чтобы узнать индекс первого вхождения подстроки `sub` в строке. Если нужно проверить, есть ли подстрока `sub` в строке или нет, используется оператор `in`:

```python showLineNumbers
>>> 'Py' in 'Python'
True
```

### `str.format(*args, **kwargs)` {#str-format-args-kwargs}

Выполняет форматирование (оформление) строки согласно правилам, заданным в [Format String Syntax](https://docs.python.org/3/library/string.html#formatstrings). Внутри строки могут находиться места для подстановки, куда будет подставляться результаты выполнения выражений, переданных в качестве аргументов. Эти места внутри строки оформляются фигурными скобками `{}`. Внутри фигурных скобок могут быть целые числа начиная с нуля, куда подставляются аргументы. Также внутри фигурных скобок могут быть выражения, сообщающие интерпретатору, какую информацию из аргументов выбрать для подстановки в строку.

```python showLineNumbers
>>> 'Привет, {}'.format('друг')
'Привет, друг'
>>> 'Привет, {0}. Меня зовут {1}'.format('друг', 'Илья')
'Привет, друг. Меня зовут Илья'
>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
```

:::info внимание

В описании метода`str.format(*args, **kwargs)` перед параметром `args` записан один символ `*` (звёздочка), а перед параметром `kwargs` записано два символа `**` (две звёздочки). Это означает, что метод может быть вызван позиционными и именованными аргументами, причём позиционные и именованные аргументы могут быть использованы совместно при вызове метода (именованные аргументы всегда должны следовать за позиционными). Подробнее распаковка именованных аргументов будет рассматриваться в главе **Функциональное программирование**.

:::

В приведённом ниже примере первый аргумент — позиционный, а второй аргумент — именованный:

```python showLineNumbers
>>> 'Привет, {0}. Меня зовут {name}'.format('друг', name='Илья')
'Привет, друг. Меня зовут Илья'
```

### `str.format_map(mapping)` {#str-format-map-mapping}

Выполняет то же самое, что `str.format()`, только аргументы передаются в виде словарей (`dict`), и при подстановке в строку аргументы подставляются не по порядку, а по имени.

```python showLineNumbers
>>> 'Привет, {call}. Меня зовут {name}'.format_map({'call': 'друг', 'name': 'Илья'})
'Привет, друг. Меня зовут Илья'
>>>
>>>
>>> class Default(dict):
...     def __missing__(self, key):
...         return key
...
>>> '{name} was born in {country}'.format_map(Default(name='Guido'))
'Guido was born in country'
```

### `str.index(sub[, start[, end]])` {#str-index-sub-start-end}

Выполняет то же самое, что `str.find()`, за исключением того, что если подстрока `sub` не найдена в исходной строке, возбуждает исключение типа `ValueError`.

```python showLineNumbers
>>> 'ананас'.index('а')
0
>>> 'ананас'.index('на')
1
>>> 'ананас'.index('б')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found
```

### `str.isalnum()` {#str-isalnum}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются буквенно-числовыми. В противном случае возвращает `False`. Символ `c` является буквенно-числовым, если хотя бы один из следующих методов вернёт True: `c.isalpha()`, `c.isdecimal()`, `c.isdigit()` или `c.isnumeric()`.

```python showLineNumbers
>>> '0123строка'.isalnum()
True
>>> '0123_строка'.isalnum()
False
>>> '0123 строка'.isalnum()
False
>>> ''.isalnum()
False
```

### `str.isalpha()` {#str-isalpha}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются буквами. В противном случае возвращает `False`.

```python showLineNumbers
>>> 'строка'.isalpha()
True
>>> '0123строка'.isalpha()
False
>>> ''.isalpha()
False
```

### `str.isascii()` {#str-isascii}

Возвращает `True`, если строка пустая или все символы в строке являются ASCII-символами. В противном случае возвращает `False`. Символы ASCII представлены в Юникоде в диапазоне U+0000—U+007F.

```python showLineNumbers
>>> ''.isascii()
True
>>> ' '.isascii()
True
>>> '0123string'.isascii()
True
>>> '0123 _/\|+-=(){}@#$string'.isascii()
True
>>> 'строка'.isascii()
False
```

### `str.isdecimal()` {#str-isdecimal}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются десятичными символами. В противном случае возвращает `False`. Десятичные символы — это цифры десятичной системы счисления и символы, которые можно использовать для записи чисел с основанием 10, например U+0660, ARABIC-INDIC DIGIT ZERO. Формально десятичные символы — это символы Юникода из категории Nd (числа, десятичные цифры).
```python showLineNumbers
>>> '0123456789'.isdecimal()
True
>>> '0 1 2 3 4 5 6 7 8 9'.isdecimal()
False
''.isdecimal()
False
>>> chr(0x0660).isdecimal()
True
>>> '0x64'.isdecimal()
False
```

### `str.isdigit()` {#str-isdigit}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются цифрами. В противном случае возвращает `False`. Цифрой считаются десятичные символы и надстрочные знаки, служащие для записи чисел. Формально цифры — это символы Юникода, имеющие значение свойства Numeric_Type=Digit или Numeric_Type=Decimal.

```python showLineNumbers
>>> '0123456789'.isdigit()
True
>>> '0 1 2 3 4 5 6 7 8 9'.isdigit()
False
>>> chr(0x0660).isdigit()
True
'0x64'.isdigit()
False
```
### `str.isidentifier()` {#str-isidentifier}

Возвращает `True`, если в строке есть хотя бы один символ, и строка является допустимым идентификатором (то есть подходит ли для названий переменных функций, классов) согласно правилам языка Python: [Identifiers and keywords](https://docs.python.org/3/reference/lexical_analysis.html#identifiers).

В примере ниже приводится также проверка, является ли строка ключевым словом в Python.

```python showLineNumbers
>>> from keyword import iskeyword

>>> 'hello'.isidentifier(), iskeyword('hello')
True, False
>>> 'def'.isidentifier(), iskeyword('def')
True, True
```

### `str.islower()` {#str-islower}

Возвращает `True` если в строке есть хотя бы один символ, и все символы, имеющие регистр, записаны в нижнем регистре. В противном случае возвращает `False`. То есть если в строке нет ни одной буквы (например, только цифры, пробелы и знаки препинания), или есть бы одна заглавная буква — вернёт `False`. Но если в строке есть и цифры, и пробелы, и знаки препинания, и строчные буквы, но нет ни одной заглавной буквы — вернёт `True`. Формально символы, имеющие регистр — это символы Юникода, имеющие значение свойства категории Lu (Letter, uppercase), Ll (Letter, lowercase) или Lt (Letter, titlecase).

```python showLineNumbers
>>> 'a-b-c'.islower()
True
>>> 'A-b-c'.islower()
False
>>> '123'.islower()
False
>>> 'a b c 1 2 3'.islower()
True
>>> '1 2 3'.islower()
False
>>> 'ß'.islower()
True
```
### `str.isnumeric()` {#str-isnumeric}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются числовыми символами. В противном случае возвращает `False`. Числовыми символами являются все цифры и символы Юникода, имеющие свойство с числовым значением. Формально числовые символы — это символы Юникода, имеющие значение свойства Numeric_Type=Digit, Numeric_Type=Decimal или Numeric_Type=Numeric.

```python showLineNumbers
>>> '0123456789'.isnumeric()
True
>>> '0 1 2 3 4 5 6 7 8 9'.isnumeric()
False
>>> '⅕'.isnumeric()
True
>>> chr(0x0660).isnumeric()
True
>>> '0x64'.isnumeric()
False
```

### `str.isprintable()` {#str-isprintable}

Возвращает `True`, если строка пустая или все символы в строке являются печатаемыми (пробел тоже является печатаемым символом). В противном случае возвращает `False`. Непечатаемые символы — это символы, которые определены в Юникоде как «Другой» или «Разделитель», за исключением пробела ASCII (0x20).

:::info внимание

Печатаемые символы в этом контексте — это те символы, которые не нужно экранировать при вызове функции [`repr()`](https://docs.python.org/3/library/functions.html#repr), применённой к строке.

:::

```python showLineNumbers
>>> ''.isprintable()
True
>>> '0 1 2 3 4 5 abcdef=-*/|\\|'.isprintable()
True
```

### `str.isspace()` {#str-isspace}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются пробельными. В противном случае возвращает `False`.  Формально пробельные символы — это символы Юникода из категории Zs (разделитель, пробел) или если их двунаправленный класс — это WS, B, или S.

```python showLineNumbers
>>> ''.isspace()
False
>>> ' '.isspace()
True
>>> '   '.isspace()
True
False
>>> ' 1a'.isspace()
False
```

### `str.istitle()` {#str-istitle}

Возвращает `True`, если в строке есть хотя бы один символ, и символы в верхнем регистре могут следовать только за символами без регистра, а символы в нижнем регистре — только за символами в верхнем регистре. В противном случае возвращает `False`.

```python showLineNumbers
>>> 'Привет'.istitle()
True
' Привет'.istitle()
True
>>> '123 Привет'.istitle()
True
>>> '123Привет'.istitle()
True
>>> 'Привет123'.istitle()
True
>>> ' Привет Привет '.istitle()
True
>>> 'Привет2Привет'.istitle()
True
>>> 'Привет2привет'.istitle()
False
>>> 'привет'.istitle()
False
>>> 'ПРИВЕТ'.istitle()
False
>>> 'ПриветПривет'.istitle()
False
>>> ''.istitle()
False
```

### `str.isupper()` {#str-isupper}

Возвращает `True`, если в строке есть хотя бы один символ, и все символы в строке являются символами в верхнем регистре. В противном случае возвращает `False`.

```python showLineNumbers
>>> 'BANANA'.isupper()
True
>>> 'banana'.isupper()
False
>>> 'baNana'.isupper()
False
>>> ' '.isupper()
False
```

### `str.join(iterable)` {#str-join-iterable}

Возвращает строку, которая является результатом конкатенации (объединения) строк — элементов итерируемого объекта, переданного в качестве аргумента. В качестве разделителя между элементами в полученной будет использована исходная строка. Если элементы итерируемого объекта не являются строками, будет возбуждено исключение типа `TypeError`.

```python showLineNumbers
>>> ', '.join(['привет', 'друг'])
'привет, друг'
>>> ', '.join('абвгдеж')
'а, б, в, г, д, е, ж'
>>> ', '.join([b'hello', b'friend'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sequence item 0: expected str instance, bytes found
```

### `str.ljust(width[, fillchar])` {#str-ljust-width-fillchar}

Возвращает строку, выровненную по левому краю с шириной, указанной в аргументе `width`. Это значит, что слева остаются исходные символы, а справа добавлено столько символов, указанных в аргументе `fillchar`, сколько нужно, чтобы получилась строка с шириной, указанной в аргументе `width`. Если метод вызван без аргумента `fillchar`, строка заполняется пробелами.

```python showLineNumbers
>>> 'привет'.ljust(20)
'привет              '
>>> len('привет'.ljust(20))
20
>>> 'привет'.ljust(20, '+')
'привет++++++++++++++'
>>> 'привет'.ljust(20, '++')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: The fill character must be exactly one character long
```

### `str.lower()` {#str-lower}

Возвращает копию строки, где все буквенные символы преобразованы к нижнему регистру. Алгоритм преобразования к нижнему регистру описан в секции 3.13 стандарта Юникода.

```python showLineNumbers
>>> 'ПРИВЕТ'.lower()
'привет'
>>> 'ПрИвЕт'.lower()
'привет'
```

### `str.lstrip([chars])` {#str-lstrip-chars}

Возвращает копию строки с удалёнными ведущими символами, указанными в аргументе. Если метод вызывается без аргумента, удаляет ведущие пробелы. Ведущие символы — это символы, находящиеся слева. Метод удаляет все символы из строки, переданной в аргументе, слева направо до тех пор, пока не встретит символ, не входящий в набор, и возвращает остаток строки. Если после символа, не входящего в набор для удаления, встречаются символы, входящие в этот набор, они сохраняются.

```python showLineNumbers
>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
```

Сравните действие метода `str.lstrip()` с действием метода `str.removeprefix()`. Метод `str.lstrip()` удаляет все символы, входяще в набор для удаления, независимо от того, в каком они переданы порядке. Метод `str.removeprefix()` удаляет подстроку слева (то есть при удалении учитывается порядок символов).

```python showLineNumbers
>>> 'Arthur: three!'.lstrip('Arthur: ')
'ee!'
>>> 'Arthur: three!'.removeprefix('Arthur: ')
'three!'
```

### `static str.maketrans(x[, y[, z]])` {#static-str-maketrans-x-y-z}

Статический метод. Возвращает словарь (`dict`), состоящих из пар `ключ:значение`. Полученный словарь передаётся в метод `str.translate()`. Метод `str.translate()` используется для множественных замен одних символов исходной строки другими. Метод `str.translate()` ищет в исходной строке ключи из словаря соответствий, полученного через вызов метода `str.maketrans()`, и заменяет их значениями. В результате получается новая строка с множественными заменами.

Метод `str.maketrans()` может быть вызван с одним, двумя и тремя аргументами.

Если метод `str.maketrans()` вызывается с одним аргументом — этим аргументом должен быть словарь, содержащий пары `ключ:значение`. Ключи и значения могут быть одиночными символами Юникода или целыми числами — кодами символов Юникода. Значения также могут быть `None` (в этих случаях соответствующие ключи не заменяются на значения, а удаляются во время замен).

Если метод `str.maketrans()` вызывается с двумя аргументами — оба аргумента должны быть строками одинаковой длины. Тогда из первой строки при создании словаря выбираются ключи, а из второй строки — значения, и из соответствующих по индексам элементов первой и второй строк создаются пары `ключ:значение`.

Если метод `str.maketrans()` вызывается с тремя аргументами, третий аргумент должен быть строкой. При создании словаря элементы этой строки становятся ключами, а значениями для них становится `None`. Поэтому при множественных заменах символы, соответствующие этим ключам, удаляются (заменяются на ничто).

```python showLineNumbers
>>> trans = str.maketrans('привет', 'тевирп', '!')
>>> trans
{1087: 1090, 1088: 1077, 1080: 1074, 1074: 1080, 1077: 1088, 1090: 1087, 33: None}
>>> 'привет!'.translate(trans)
'тевирп'
>>> 'Привет!'.translate(trans)
'Певирп'
>>> trans = str.maketrans({'п': 'т', 'р': 'е', 'и': 'в', 'в': 'р', 'е': 'и', 'т': 'п', '!': None})
>>> trans
{1087: 'т', 1088: 'е', 1080: 'в', 1074: 'р', 1077: 'и', 1090: 'п', 33: None}
>>> 'привет!'.translate(trans)
'теврип'
>>> 'Привет!'.translate(trans)
'Певрип'
```

### `str.partition(sep)` {#str-partition-sep}

Разделяет исходную строку на части по первому вхождению подстроки `sep` и возвращает кортеж из трёх элементов: часть исходной строки слева от подстроки `sep`, подстрока `sep`  и часть исходной строки справа от подстроки `sep`. Если подстрока `sep` не найдена в исходной строке, первым элементом кортежа будет строка, равная исходной строке, а вторым и третьим элементами будут пустые строки.

```python showLineNumbers
>>> 'ананас'.partition('ан')
('', 'ан', 'анас')
>>> 'ананас'.partition('на')
('а', 'на', 'нас')
>>> 'ананас'.partition(' ')
('ананас', '', '')
>>> 'ананас'.partition('')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: empty separator
```

### `str.removeprefix(prefix, /)` {#str-removeprefix-prefix-slash}

Если исходная строка начинается с подстроки `prefix`, возвращает копию строки без подстроки `prefix`, что эквивалентно выполнению выражения `string[len(prefix):]`. В противном случае возвращает копию исходной строки.

```python showLineNumbers
>>> 'TestHook'.removeprefix('Test')
'Hook'
>>> 'BaseTestCase'.removeprefix('Test')
'BaseTestCase'
```

:::info внимание

В объявлении метода `str.removeprefix(prefix, /)` после параметра `prefix` записан символ `/` (прямой слеш). В главе **[Функции. Начало](/docs/python-language/functions-beginning)** приводилось объяснение этого символа при объявлении функций. Для методов этот символ имеет то же значение, что и для функций. Наличие этого символа говорит о том, что при вызове метода аргументы, соответствующие параметрам, объявленным пере символом `/`, могут быть только позиционными.

:::

Если попытаться вызвать метод, передав аргумент `prefix` как именованный аргумент, будет возбужденно исключение типа `TypeError`:

```python showLineNumbers
>>> 'TestHook'.removeprefix(prefix='Test')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: str.removeprefix() takes no keyword arguments
```

### `str.removesuffix(suffix, /)` {#str-removesuffix-suffix-slash}

Если исходная строка заканчивается подстрокой `suffix`, возвращает копию строки без подстроки `suffix`, что эквивалентно выполнению выражения `string[:-len(suffix)]`. В противном случае возвращает копию исходной строки.

:::info внимание

В объявлении метода `str.removeprefix(prefix, /)` после параметра `prefix` записан символ `/` (прямой слеш). Это значит, что аргумент `suffix` может быть только позиционным.

:::

```python showLineNumbers
>>> 'MiscTests'.removesuffix('Tests')
'Misc'
>>> 'TmpDirMixin'.removesuffix('Tests')
'TmpDirMixin'
```

### `str.replace(old, new[, count])` {#str-replace-old-new-count}

Возвращает копию исходной строки, где все вхождения подстроки `old` заменены на подстроку `new`. Если указан необязательный аргумент `count` (целое число), заменяются столько найденных первых вхождений подстроки `old`, сколько указано в аргументе `count`.

```python showLineNumbers
>>> 'ананас'.replace('а', 'ба')
'банбанбас'
>>> 'ананас'.replace('а', 'ба', 1)
'бананас'
>>> 'ананас'.replace('а', 'ба', 2)
'банбанас'
>>> 'ананас'.replace('а', 'ба', 3)
'банбанбас'
>>> 'ананас'.replace('а', 'ба', 0)
'ананас'
>>> 'ананас'.replace('а', 'ба', -1)
'банбанбас'
```

### `str.rfind(sub[, start[, end]])` {#str-rfind-sub-start-end}

Возвращает индекс последнего найденного вхождения подстроки `sub` в исходной строке. Если подстрока не найдена, возвращает `-1`. Необязательные аргументы `start` и `end` интерпретируются как границы среза, в пределах которого ведётся поиск.

```python showLineNumbers
>>> 'ананас'.rfind('а')
4
>>> 'ананас'.rfind('а', 0, 3)
2
>>> 'ананас'.rfind('б')
-1
```

### `str.rindex(sub[, start[, end]])` {#str-rindex-sub-start-end}

Выполняет то же самое, что `str.rfind()`, за исключением того, что если подстрока `sub` не найдена в исходной строке, возбуждает исключение типа `ValueError`.

```python showLineNumbers
>>> 'ананас'.rindex('а')
4
>>> 'ананас'.rindex('на')
3
>>> 'ананас'.rindex('б')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found
```

### `str.rjust(width[, fillchar])` {#str-rjust-width-fillchar}

Возвращает строку, выровненную по правому краю с шириной, указанной в аргументе `width`. Это значит, что справа остаются исходные символы, а слева добавлено столько символов, указанных в аргументе `fillchar`, сколько нужно, чтобы получилась строка с шириной, указанной в аргументе `width`. Если метод вызван без аргумента `fillchar`, строка заполняется пробелами.

```python showLineNumbers
>>> 'привет'.rjust(20)
'              привет'
>>> len('привет'.rjust(20))
20
>>> 'привет'.rjust(20, '+')
'++++++++++++++привет'
>>> 'привет'.rjust(20, '++')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: The fill character must be exactly one character long
```

### `str.rpartition(sep)` {#str-rpartition-sep}

Разделяет исходную строку на ти части по последнему вхождению подстроки `sep` и возвращает кортеж из трёх элементов: часть исходной строки слева от подстроки `sep`, подстрока `sep` и часть исходной строки справа от подстроки `sep`. Если подстрока `sep` не найдена в исходной строке, первым и вторым элементами кортежа будут пустые строки, а последним элементом будет строка, равная исходной строке.

```python showLineNumbers
>>> 'ананас'.rpartition('ан')
('ан', 'ан', 'ас')
>>> 'ананас'.rpartition('на')
('ана', 'на', 'с')
>>> 'ананас'.rpartition(' ')
('', '', 'ананас')
>>> 'ананас'.rpartition('')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: empty separator
```

### `str.rsplit(sep=None, maxsplit=-1)` {#str-rsplit-sep-none-maxsplit-minus-1}

Возвращает список, состоящий из строк, полученных в результате разделения исходной строки подстрокой `sep`. Разделение исходной строки выполняется справа налево. Если метод вызывается без аргументов, в качестве разделителя используется пробел. Если метод вызывается со вторым необязательным аргументом `maxsplit`, разделение строки выполняется максимум столько раз, сколько указано в аргументе `maxsplit`. Если в результате разделения образуются пустые строки, они включаются в результирующий список.

```python showLineNumbers
>>> 'ананас'.rsplit('ан')
['', '', 'ас']
>>> 'ананас'.rsplit('на')
['а', '', 'с']
>>> 'ананас'.rsplit('ана')
['ан', 'с']
>>> 'привет, друг'.rsplit()
['привет,', 'друг']
>>> 'привет, друг'.rsplit(', ')
['привет', 'друг']
>>> 'привет, друг'.rsplit('р', 2)
['п', 'ивет, д', 'уг']
>>> 'привет, друг'.rsplit('р', 2)
['п', 'ивет, д', 'уг']
```

### `str.rstrip([chars])` {#str-rstrip-chars}

Возвращает копию строки с удалёнными завершающими символами, указанными в аргументе. Если метод вызывается без аргумента, удаляет завершающие пробелы. Завершающие символы — это символы, находящиеся справа. Метод удаляет все символы из строки, переданной в аргументе, справа налево до тех пор, пока не встретит символ, не входящий в набор, и возвращает остаток строки. Если перед символом, не входящим в набор для удаления, встречаются символы, входящие в этот набор, они сохраняются.

```python showLineNumbers
>>> '   spacious   '.rstrip()
'   spacious'
>>> 'mississippi'.rstrip('ipz')
'mississ'
```

Сравните действие метода `str.rstrip()` с действием метода `str.removesuffix()`. Метод `str.rstrip()` удаляет все символы, входяще в набор для удаления, независимо от того, в каком они переданы порядке. Метод `str.removesuffix()` удаляет подстроку справа (то есть при удалении учитывается порядок символов).

```python showLineNumbers
>>> 'Monty Python'.rstrip(' Python')
'M'
>>> 'Monty Python'.removesuffix(' Python')
'Monty'
```

### `str.split(sep=None, maxsplit=-1)` {#str-split-sep-none-maxsplit-minus-1}

Возвращает список, состоящий из строк, полученных в результате разделения исходной строки подстрокой `sep`. Разделение исходной строки выполняется слева направо. Если метод вызывается без аргументов, в качестве разделителя используется пробел. Если метод вызывается со вторым необязательным аргументом `maxsplit`, разделение строки выполняется максимум столько раз, сколько указано в аргументе `maxsplit`. Если в результате разделения образуются пустые строки, они включаются в результирующий список.

```python showLineNumbers
>>> '1,2,3'.split(',')
['1', '2', '3']
>>> '1,2,3'.split(',', maxsplit=1)
['1', '2,3']
>>> '1,2,,3,'.split(',')
['1', '2', '', '3', '']
>>> '1 2 3'.split()
['1', '2', '3']
>>> '1 2 3'.split(maxsplit=1)
['1', '2 3']
>>> '   1   2   3   '.split()
['1', '2', '3']
>>> ''.split()
[]
>>> ' '.split()
[]
```

### `str.splitlines([keepends])` {#str-splitlines-keepends}

Возвращает список, состоящий из строк, полученных в результате разделения исходной строки. В качестве разделителей используются символы новой строки. Символы новой строки при этом не включаются в полученные строки. Если метод вызывается с необязательным аргументом `keepends`, равным `True`, символы новой строки включаются в полученные строки.

Ниже представлен полный список символов, интерпретируемых как разделители текста на строки.

### Таблица 3. Символы, интерпретируемые как разделители текста на строки {#tablet-3-characters-interpreted-as-line-boundaries}

| Представление         | Описание                              |
| --------------------- | ------------------------------------- |
| `\n`                  | Перевод строки                        |
| `\r`                  | Возврат каретки                       |
| `\r\n`                | Возврат каретки + перевод строки      |
| `\v` или `\x0b`       | Вертикальная табуляция                |
| `\f` или `\x0c`       | Новая страница                        |
| `\x1c`                | Разделитель файлов                    |
| `\x1d`                | Разделитель групп                     |
| `\x1e`                | Разделитель записей                   |
| `\x85`                | Переход на следующую строку           |
| `\u2028`              | Разделитель строк                     |
| `\u2029`              | Разделитель абзацев                   |

```python showLineNumbers
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
['ab c', '', 'de fg', 'kl']
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
['ab c\n', '\n', 'de fg\r', 'kl\r\n']
```

В отличие от метода `str.split()`, метод `str.splitlines()` возвращает пустой список, если исходная строка пустая, и символ новой строки в конце исходной строки не образует дополнительную пустую строку в полученном списке:

```python showLineNumbers
>>> ''.splitlines()
[]
>>> 'One line\n'.splitlines()
['One line']
```

Для сравнения метод `str.split()` даёт следующий результат:

```python showLineNumbers
>>> ''.split('\n')
['']
>>> 'Two lines\n'.split('\n')
['Two lines', '']
```

### `str.startswith(prefix[, start[, end]])` {#str-startswith-prefix-start-end}

Возвращает `True`, если строка начинается подстрокой, указанной в аргументе `prefix`. В противном случае возвращает `False`. Аргумент `prefix` также может быть кортежем, состоящим из строк — в этом случае сопоставление ведётся с каждым элементом кортежа, и если хотя бы один элемент кортежа совпадает с началом строки, возвращается `True`. Необязательные аргументы `start` и `end` интерпретируются как границы среза, в пределах которого ведётся поиск.

```python showLineNumbers
>>> 'привет'.startswith('при')
True
>>> 'привет'.startswith('ри', 1)
True
>>> 'привет'.startswith('ри', 1, 3)
True
>>> 'привет'.startswith('про')
False
>>> 'привет'.startswith(('ври', 'при'))
True
```

### `str.strip([chars])` {#str-strip}

Возвращает копию строки с удалёнными ведущими и завершающими символами, указанными в аргументе. Если метод вызывается без аргумента, удаляет ведущие и завершающие пробелы. Ведущие символы — это символы, находящиеся слева. Завершающие символы — это символы, находящиеся справа. Метод удаляет все символы из строки, переданной в аргументе, слева направо до тех пор, пока не встретит символ, не входящий в набор. То же самое выполняется справа налево. После этого возвращается остаток строки. Если при обработке слева направо после символа, не входящего в набор для удаления, встречаются символы, входящие в этот набор, они сохраняются. Это же правило выполняется при обработке справа налево.

```python showLineNumbers
>>> '   spacious   '.strip()
'spacious'
>>> 'www.example.com'.strip('cmowz.')
'example'
>>> comment_string = '#....... Section 3.2.1 Issue #32 .......'
>>> comment_string.strip('.#! ')
'Section 3.2.1 Issue #32'
```

### `str.swapcase()` {#str-swapcase}

Возвращает копию строки с символами, у которых инвертирован регистр — если в исходной строке символ представлен в верхнем регистре, он заменяется соответствующим символом в нижнем регистре, и наоборот. Символы, не имеющие регистра, не преобразуются. Следует иметь в виду, что результат выполнения выражения `s.swapcase().swapcase()` не во всех случаях будет равен исходной строке `s`.

```python showLineNumbers
>>> 'привет'.swapcase()
'ПРИВЕТ'
>>> 'ПрИвЕт'.swapcase()
'пРиВеТ'
>>> '01 ПрИвЕт'.swapcase()
'01 пРиВеТ'
>>> 'привет'.swapcase().swapcase()
'привет'
```

### `str.title()` {#str-title}

Возвращает копию исходной строки, в которой во всех подстроках, состоящих из букв, первый символ представлен в верхнем регистре, а остальные — в нижнем.  Если в последовательности символов находятся символы, не являющиеся буквенными, они считаются разделителями.

```python showLineNumbers
>>> 'Hello, world'.title()
'Hello, World'
>>> 'Hello2world'.title()
'Hello2World'
```

Алгоритм метода не зависит от языка, поэтому не учитывает, что в английском языке слова в притяжательном падеже включают в себя апостроф. В результате буква `'s'`после апострофа возвращается в верхнем регистре:

```python showLineNumbers
>>> "they're bill's friends from the UK".title()
"They'Re Bill'S Friends From The Uk"
```

Чтобы получить заголовки, принятые в английском языке, можно дополнительно воспользоваться регулярными выражениями:

```python showLineNumbers
>>> import re
>>> def titlecase(s):
...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
...                   lambda mo: mo.group(0).capitalize(),
...                   s)
...
>>> titlecase("they're bill's friends.")
"They're Bill's Friends."
```

### `str.translate(table)` {#str-translate-table}

Метод `str.translate()` используется для множественных замен одних символов исходной строки другими. Метод `str.translate()` ищет в исходной строке ключи из словаря соответствий, полученного через вызов метода `str.maketrans()`, и заменяет их значениями. В результате получается новая строка с множественными заменами.

```python showLineNumbers
>>> trans = str.maketrans('привет', 'тевирп', '!')
>>> trans
{1087: 1090, 1088: 1077, 1080: 1074, 1074: 1080, 1077: 1088, 1090: 1087, 33: None}
>>> 'привет!'.translate(trans)
'тевирп'
>>> 'Привет!'.translate(trans)
'Певирп'
>>> trans = str.maketrans({'п': 'т', 'р': 'е', 'и': 'в', 'в': 'р', 'е': 'и', 'т': 'п', '!': None})
>>> trans
{1087: 'т', 1088: 'е', 1080: 'в', 1074: 'р', 1077: 'и', 1090: 'п', 33: None}
>>> 'привет!'.translate(trans)
'теврип'
>>> 'Привет!'.translate(trans)
'Певрип'
```

### `str.upper()` {#str-upper}

Возвращает копию строки, где все буквенные символы преобразованы к верхнему регистру. Алгоритм преобразования к верхнему регистру описан в секции 3.13 стандарта Юникода.

```python showLineNumbers
>>> 'привет'.upper()
'ПРИВЕТ'
>>> 'ПрИвЕт'.upper()
'ПРИВЕТ'
```

### `str.zfill(width)` {#str-zfill-width}

Возвращает копию строки заполненную слева символом ASCII `0` (ноль) так, чтобы получилась строка с шириной, указанной в аргументе, имеющую ширину, указанную в аргументе. Если исходная строка начинается с символов `+` или `-` (знаки положительных и отрицательных чисел), в копии строки сначала ставится соответствующий знак, а недостающее до указанной ширины количество символов заполняется нулями. Если ширина исходной строки равна или меньше указанной в аргументе ширины, возвращается копия исходной строки.

```python showLineNumbers
>>> "42".zfill(5)
'00042'
>>> "-42".zfill(5)
'-0042'
>>> 'привет'.zfill(10)
'0000привет'
>>> '+привет'.zfill(10)
'+000привет'
>>> '*привет'.zfill(10)
'000*привет'
```

## Форматирование строк. Общая информация {#string-formatting-common-information}

В Python существует несколько способов форматирования строк:

- форматирование в стиле функции `printf()` из языка C;
- форматирование согласно правилам, применяемым в методах `str.format()`, `str.format_map()` и классе [`string.Formatter`](https://docs.python.org/3/library/string.html#string.Formatter), входящего в модуль [`string`](https://docs.python.org/3/library/string.html#module-string);
- форматирование согласно правилам, применяемым к строкам, литералы которых содержат префикс `'f'`.

Рассмотрим каждый из них в порядке появления.

## Форматирование строк в стиле функции `printf()` из языка C {#printf-style-string-formatting}

Данный способ — самый старый. Он взят из языка C. В языке C есть семейство функций для форматированного вывода (`printf()`, `sprintf()`) и ввода (`scanf()`, `sscanf()`).

Этот же способ используется в других языках программирования, например, в PHP, где есть одноимённые функции-обёртки над соответствующими функциями языка C.

В документации по Python говорится, что операции форматирования в стиле функции `sprintf()` языка C имеют ряд особенностей, которые приводят к ошибкам (например, неправильное отображение кортежей и словарей). Однако при внимательном оформлении программ этих ошибок можно избежать и успешно применять форматирование в стиле C.

Строковые объекты поддерживают операцию форматирования (или, иначе, интерполяции, то есть подстановки значений в строки), обозначаемую оператором `%`. Форматирование строк также называется интерполяцией по аналогии с [интерполяцией](https://ru.wikipedia.org/wiki/Интерполяция_(текстология)) в текстологии, поскольку форматирование строк включает в себя подстановку значений в строки. Таким образом, оператор `%` в языке Python обозначает две разные операции: применительно к строкам он обозначает форматирование, а применительно к числам — взятие остатка от деления с остатком.

Запись операции форматирования в Python в общем виде выглядит так: `строка, к которой применяется форматирование % значение или значения, подставляемые в строку`.

Простейший пример форматирования строк:

```python showLineNumbers
>>> 'Привет, %s!' % 'мир'
'Привет, мир!'
```

В этом примере:

- `'Привет, %s!'` — это строка, к которой применяется форматирование;
- `'%s'` — спецификатор: символ `'%'` указывает на начало спецификатора; символ `'s'` означает, что в строку нужно подставлять строковое представление объекта (смотрите ниже таблицу 5);
- `%` — оператор форматирования строк;
- `'мир'` — значение, подставляемое в строку вместо спецификатора по правилам, указанным в спецификаторе — в данном случае это строка, заданная через литерал.

При рассмотрении форматирования строк можно провести аналогию с функциями. Строка, к которой применяется форматирование, может быть рассмотрена как функция, объявленная с параметрами. А значения, подставляемые в строку, могут быть рассмотрены как аргументы вызова функции.

Строка, к которой применяется форматирование, может быть литералом или переменной. Одиночное значение может быть литералом или переменной, ссылающейся на объект любого типа. Если значений несколько, они должны быть заданы литералом кортежа (`tuple`) или словаря (`dict`) или переменной, ссылающейся на кортеж или словарь.

Разберём ещё пример:

```python showLineNumbers
>>> 'Привет, %s! Меня зовут %s.' % ('мир', 'Илья')
'Привет, мир! Меня зовут Илья.'
```

В этом примере:

- `'Привет, %s! Меня зовут %s.'` — это строка, к которой применяется форматирование;
- `'%s'` и `'%s'` — спецификаторы, означающие, что нужно подставлять строковые представления объектов;
- `%` — оператор форматирования строк;
- `('мир', 'Илья')` — кортеж из двух элементов, содержащий значения, подставляемые в строку вместо спецификаторов в том порядке, в котором они объявлены в кортеже.

Количество элементов в кортеже должно совпадать с количеством спецификаторов в строке, к которой нужно применить форматирование. В противном случае будет возбуждено исключение типа `TypeError` с сообщением `TypeError: not enough arguments for format string`.

:::info внимание

Кортеж, применяемый совместно с оператором форматирования строк, должен быть заключён в круглые скобки. Если этого не сделать, интерпретатор не сможет распознать кортеж, и будет возбуждено типа `TypeError`  с сообщением `TypeError: not enough arguments for format string`, как показано в примере ниже:

:::

```python showLineNumbers
>>> 'Привет, %s! Меня зовут %s.' % 'мир', 'Илья'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: not enough arguments for format string
```

Значения для подстановки в строку, к которой применяется форматирование, могут содержаться в словарях.

Словарь — это коллекция, в которой доступ к элементам осуществляется не по индексам, а по именам, подобно тому, как доступ к объектам осуществляется по именам переменных. Имена элементов словарей также называются ключами. Подробно о словарях будет сказано в подсекции **[Словари](/docs/python-language/built-in-data-types/dictionaries)**.

Пример словаря: `{'name': 'Илья', 'world': 'мир'}`.

Доступ к элементам осуществляется через выражение `переменная['ключ']`, например:

```python showLineNumbers
>>> a = {'name': 'Илья', 'world': 'мир'}
>>> a['name']
'Илья'
>>> a['world']
'мир'
```

Если значения для передачи в строку, к которой применяется форматирование, содержатся в словарях, все спецификаторы в строке должны включать ключи словаря в круглых скобках. При этом порядок следования элементов в словаре не важен. Главное, чтобы словарь включал в себе элементы с ключами, указанными в спецификаторах:

```python showLineNumbers
>>> 'Привет, %(world)s! Меня зовут %(name)s.' % {'name': 'Илья', 'world': 'мир'}
'Привет, мир! Меня зовут Илья.'
```

Словарь может включать в себя больше элементов, чем требуется для форматирования строки. Основное требование — в словаре должны быть все элементы с ключами, указанными в спецификаторах строки. Поэтому можно создать один словарь и применять его для форматирования нескольких строк. Интерпретатор подставит значения нужных элементов словаря в строки, а остальные элементы проигнорирует:

```python showLineNumbers
>>> values = {'name': 'Илья', 'world': 'мир'}
>>> 'Привет, %(world)s!' % values
'Привет, мир!'
>>> 'Меня зовут %(name)s.' % values
'Меня зовут Илья.'
```

Форматирование строк можно применять совместно с локальными переменными, упаковывая переменные в словарь при помощи встроенной функции [`vars()`](https://docs.python.org/3/library/functions.html#vars). Функция `vars()` возвращает словарь, ключами которого являются имена локальных переменных, а значениями — ссылки на объекты, на которые ссылаются эти переменные. Пример форматирования строк совместно с функцией `vars()`:

```python showLineNumbers
>>> name = 'Илья'
>>> world = 'мир'
>>> 'Привет, %(world)s! Меня зовут %(name)s.' % vars()
'Привет, мир! Меня зовут Илья.'
```

:::info внимание

Если в строке только один спецификатор, спецификатор не содержит имя элемента, и значение представлено словарём из одного элемента, интерпретатор преобразует в строку весь словарь вместо того, чтобы взять только значение элемента:

:::

```python showLineNumbers
>>> 'Привет, %s!' % {'world': 'мир'}
"Привет, {'world': 'мир'}!"
```

Это происходит потому, что, если спецификатор не содержит имя элемента, интерпретатор преобразует весь объект согласно правилам, записанным в спецификаторе. Запись `'%s'` означает, что нужно преобразовать объект к строке, а результат преобразования к строке выглядит так:

```python showLineNumbers
>>> str({'world': 'мир'})
"{'world': 'мир'}"
```

Если строка, к которой применяется форматирование, содержит несколько спецификаторов, и спецификаторы не включают в себя ключи словаря, будет возбуждено исключение типа `TypeError`:

```python showLineNumbers
>>> 'Привет, %s! Меня зовут %s.' % {'name': 'Илья', 'world': 'мир'}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: not enough arguments for format string
```

Поэтому, во избежание ошибок, **если значения переданы словарём, спецификаторы должны включать в себя имена (ключи) элементов словаря**.

Строка, к которой применяется форматирование, может быть задана переменной:

```python showLineNumbers
>>> string = 'Привет, %(world)s! Меня зовут %(name)s.'
>>> values = {'name': 'Илья', 'world': 'мир'}
>>> result = string % values
>>> result
'Привет, мир! Меня зовут Илья.'
```

Теперь разберём подробно, что такое спецификатор.

Спецификатор преобразования содержит два или более символа и следующие компоненты, которые должны встречаться в таком порядке (порядок важен):

1. Символ `'%'`, обозначающий начало спецификатора.
2. Ключ сопоставления (необязательно), состоящий из заключённой в круглые скобки последовательности символов (например, `'(name)'`).
3. Флаги преобразования (необязательно), которые влияют на результат некоторых типов преобразования (перечислены в таблице 4).
4. Минимальная ширина поля — положительное целое число (необязательно). Если минимальная ширина указана как `'*'` (звёздочка), фактическая ширина считывается из следующего элемента кортежа значений, а объект для преобразования появляется после минимальной ширины поля и необязательной точности.
5. Точность (необязательно), обозначается как `'.'` (точка), за которой следует положительное целое число. Если точность указана как `'*'` (звёздочка), фактическая точность считывается из следующего элемента кортежа значений, а значение, которое нужно преобразовать, идёт после точности.
6. Модификатор длины числа (`'h'`, `'l'`, или `'L'`) (необязательно). Модификатор `'h'` означает короткое целое, `'l'` — длинное целое, `'L'` — очень длинное целое число. Этот модификатор имеет смысл в языке C, где есть три типа целых чисел, но в Python он игнорируется, так как целые числа в Python представлены одним типом. Поэтому, например, спецификатор `'%ld'` интерпретируется как `'%d'`.
7. Тип преобразования (один из символов, перечисленных в таблице 5).

Только символ `'%'`, обозначающий начало спецификатора и символ, обозначающий тип преобразования, записываемый в конце спецификатора, являются обязательными. Все остальные компоненты необязательны.

### Таблица 4. Флаги преобразования значений {#table-4-conversion-flag-characters}

| Флаг  | Описание |
| ----- | -------- |
| `'#'` | При преобразовании значения будет использоваться альтернативная форма, если она есть (смотрите примечания к таблице 5). Если альтернативная форма для спецификатора не предусмотрена, этот флаг игнорируется. |
| `'0'` | Преобразование будет дополнено нулями для числовых значений. Для нечисловых значений этот флаг игнорируется. |
| `'-'` | Преобразованное значение выравнивается по левому краю. Этот флаг имеет приоритет над флагом `'0'` и отменяет его, если даны оба флага. |
| `' '` | Пробел. Перед положительным числом, полученным в результате знаковых преобразований, или пустой строкой оставляется пробел. Для остальных значений этот флаг игнорируется. |
| `'+'` | Принудительно добавляет знак положительного (`'+'`) или отрицательного (`'-'`) числа к числовому значению. Этот флаг имеет приоритет над флагом пробела и отменяет его, если даны оба флага. Для нечисловых значений этот флаг игнорируется. |

### Таблица 5. Типы преобразований значений {#table-5-conversion-types}

| Преобразование | Описание | Примечание |
| -------------- | -------- | ---------- |
| `'d'`          | Знаковое целое десятичное число.  | 6 |
| `'i'`          | Знаковое целое десятичное число.  | 6 |
| `'o'`          | Знаковое восьмеричное число.      | 1 |
| `'u'`          | Устаревший тип беззнакового целого десятичного числа — в настоящее время идентично `'d'`. | 7 |
| `'x'`          | Знаковое шестнадцатеричное число (алфавитные символы в нижнем регистре).  | 2 |
| `'X'`          | Знаковое шестнадцатеричное число (алфавитные символы в верхнем регистре). | 2 |
| `'e'`          | Число с плавающей точкой в экспоненциальном формате (алфавитные символы в нижнем регистре).  | 3 |
| `'E'`          | Число с плавающей точкой в экспоненциальном формате (алфавитные символы в верхнем регистре). | 3 |
| `'f'`          | Число с плавающей точкой в десятичном представлении. | 3, 8 |
| `'F'`          | Число с плавающей точкой в десятичном представлении. | 3, 8 |
| `'g'`          | Число с плавающей точкой в десятичном представлении. Используется экспоненциальный формат в нижнем регистре, если показатель степени меньше `-4` или не меньше точности чисел с плавающей точкой. В противном случае используется десятичный формат. | 4 |
| `'G'`          | Число с плавающей точкой в десятичном представлении. Используется экспоненциальный формат в верхнем регистре, если показатель степени меньше `-4` или не меньше точности чисел с плавающей точкой. В противном случае используется десятичный формат. | 4 |
| `'c'`          | Одиночный символ. Принимает целое число (код символа) или строку, состоящую из одного символа. |   |
| `'r'`          | Строка (преобразует любой объект Python с помощью функции `repr()`.  | 5 |
| `'s'`          | Строка (преобразует любой объект Python с помощью функции `str()`.   | 5 |
| `'a'`          | Строка (преобразует любой объект Python с помощью функции `ascii()`. | 5 |
| `'%'`          | Применяется для вставки в результирующую строку символа `'%'`. Никакого аргумента не требуется. |   |

### Примечания к таблице 5 {#notes-to-table-5}

1. В альтернативной форме перед первой цифрой вставляется начальный восьмеричный спецификатор `'0o'`.
<p>Форма по умолчанию:</p>
```python showLineNumbers
>>> '%o' % 64
'100'
```
<p>Альтернативная форма:</p>
```python showLineNumbers
>>> '%#o' % 64
'0o100'
```
2. В альтернативной форме перед первой цифрой вставляется начальный `'0x'` или `'0X'` (в зависимости от того, использовался ли формат `'x'` или `'X'`).
<p>Форма по умолчанию:</p>
```python showLineNumbers
>>> '%x' % 256
'100'
```
<p>Альтернативная форма:</p>
```python showLineNumbers
>>> '%#x' % 256
'0x100'
>>> '%#X' % 256
'0X100'
```
3. В альтернативной форме результат всегда содержит десятичную точку, даже если за ней нет цифр. Точность определяется количеством цифр после десятичной точки и по умолчанию равно 6.
<p>Форма по умолчанию:</p>
```python showLineNumbers
>>> '%f' % 2
'2.000000'
>>> '%.0f' % 2
'2'
```
<p>Альтернативная форма:</p>
```python showLineNumbers
>>> '%#f' % 2
'2.000000'
>>> '%#.0f' % 2
'2.'
```
4. В альтернативной форме результат всегда содержит десятичную точку, а конечные нули не удаляются, как в форме по умолчанию. Точность определяется количеством цифр до и после десятичной точки и по умолчанию равна 6.
<p>Форма по умолчанию:</p>
```python showLineNumbers
>>> '%g' % 2_000_000
'2e+06'
```
<p>Альтернативная форма:</p>
```python showLineNumbers
>>> '%#g' % 2_000_000
'2.00000e+06'
```
5. Если точность равна `N`, вывод обрезается до `N` символов.
<p>Форма по умолчанию:</p>
```python showLineNumbers
'%.3s' % 5.555555
'5.5'
```
<p>Альтернативная форма:</p>
```python showLineNumbers
>>> '%#.3s' % 5.555555
'5.5'
```
6. В Python преобразования `%d` и `%i` ведут себя одинаково. Преобразование `%i` отличается от преобразования `%d` в языке C при использовании в функции `scanf()`. В Python рекомендуется использовать `%d`.
7. В Python 3 длинные целые и целые числа объединены в один тип данных и отсутствует отдельный тип для беззнаковых целых чисел, поэтому нет необходимости специально указывать преобразование к беззнаковому целому числу. Подробнее: [PEP 237](https://www.python.org/dev/peps/pep-0237/).
8. Преобразования `%f` и `%F` ведут себя одинаково.

<CodeBlock language="python" title="strings_5.py" showLineNumbers>{strings_5}</CodeBlock>

В примере 5 на строке 4 задаётся словарь, из которого будут браться значения для подстановки в строки.

## Дополнительные ссылки {#additional-links}

- [Юникод](https://ru.wikipedia.org/wiki/Юникод)
- [UTF-8](https://ru.wikipedia.org/wiki/UTF-8)
- [UTF-16](https://ru.wikipedia.org/wiki/UTF-16)
- [UTF-32](https://ru.wikipedia.org/wiki/UTF-32)
- [Маркер последовательности байтов](https://ru.wikipedia.org/wiki/Маркер_последовательности_байтов)
- [ASCII](https://ru.wikipedia.org/wiki/ASCII)
- [ISO 8859-1](https://ru.wikipedia.org/wiki/ISO_8859-1)
- [Code point](https://en.wikipedia.org/wiki/Code_point)
- [Плоскость (Юникод)](https://ru.wikipedia.org/wiki/Плоскость_(Юникод))
- [Кириллица в Юникоде](https://ru.wikipedia.org/wiki/Кириллица_в_Юникоде)
- [Кавычки](https://ru.wikipedia.org/wiki/Кавычки)
- [Символьный тип](https://ru.wikipedia.org/wiki/Символьный_тип)
- [Диграф](https://ru.wikipedia.org/wiki/Диграф)
- [Управляющая последовательность](https://ru.wikipedia.org/wiki/Управляющая_последовательность)
- [Управляющие символы](https://ru.wikipedia.org/wiki/Управляющие_символы)
- [Экранирование символов](https://ru.wikipedia.org/wiki/Экранирование_символов)
- [Переносимый набор символов](https://ru.wikipedia.org/wiki/Переносимый_набор_символов)
- [Перевод строки](https://ru.wikipedia.org/wiki/Перевод_строки)
- [Интерполяция (текстология)](https://ru.wikipedia.org/wiki/Интерполяция_(текстология))
- [Шебанг (Unix)](https://ru.wikipedia.org/wiki/Шебанг_(Unix))
- [Emacs](https://ru.wikipedia.org/wiki/Emacs)
- [Спецификация](https://ru.wikipedia.org/wiki/Спецификация)
- [Глиф](https://ru.wikipedia.org/wiki/Глиф)
- [Графема](https://ru.wikipedia.org/wiki/Графема)
- [Обратная совместимость](https://ru.wikipedia.org/wiki/Обратная_совместимость)
- [Портирование программного обеспечения](https://ru.wikipedia.org/wiki/Портирование_программного_обеспечения)
- [Конструктор (объектно-ориентированное программирование)](https://ru.wikipedia.org/wiki/Конструктор_(объектно-ориентированное_программирование))
