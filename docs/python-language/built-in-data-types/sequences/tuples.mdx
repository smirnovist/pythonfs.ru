---
sidebar_position: 2
---

import CodeBlock from '@theme/CodeBlock';
import tuples_1 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_1.py';
import tuples_2 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_2.py';
import tuples_3 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_3.py';
import tuples_4 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_4.py';
import tuples_5 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_5.py';
import tuples_6 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_6.py';
import tuples_7 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_7.py';
import tuples_8 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_8.py';
import tuples_9 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_9.py';
import tuples_10 from '!!raw-loader!/static/examples/python-language/built-in-data-types/sequences/tuples/tuples_10.py';

# Кортежи

## Кортежи. Общая информация {#tuples-general-information}

Кортеж (`tuple`) — это **неизменяемая** последовательность (то есть индексируемая коллекция), обычно используемая для хранения коллекций разнородных данных. Например, встроенная функция [`enumerate()`](https://docs.python.org/3/library/functions.html#enumerate) возвращает итератор, возвращающий кортежи из двух элементов на каждой итерации. Кортежи также используются в случаях, когда требуется неизменяемая последовательность однородных данных. Например, кортежи могут быть элементами множеств или словарей.

Есть несколько способов объявления кортежей:

- использование пары круглых скобок при объявлении пустого кортежа: `()`;
- использование завершающей запятой при объявлении кортежа, состоящего из одного элемента: `a,` или `(a,)`;
- разделение элементов запятыми при объявлении кортежа из нескольких элементов: `a, b, c` или `(a, b, c)`;
- использование встроенной функции [`tuple()`](https://docs.python.org/3/library/functions.html#func-tuple) с аргументом или без.

### `class tuple([iterable])` {#class-tuple-iterable}

Функция-[конструктор](https://ru.wikipedia.org/wiki/Конструктор_(объектно-ориентированное_программирование)) `tuple()` создаёт кортеж, элементы которого являются ссылками на те же объекты и в том же порядке, что и элементы итерируемого объекта, передаваемого в функцию в качестве аргумента (смотрите пример 3). Итерируемый объект может быть либо последовательностью, либо контейнером, поддерживающим механизм итерации, либо объектом-итератором. Если итерируемый объект, передаваемый в функцию `tuple()`, сам является кортежем, он возвращается без изменений. Например, выражение `tuple('abc')` (аргумент вызова функции — строка `abc`) возвращает ссылку на кортеж `('a', 'b', 'c')`, а выражение `tuple([1, 2, 3])` (аргумент вызова функции — список из трёх элементов) возвращает ссылку на кортеж `(1, 2, 3)`. Если при вызове функции `tuple()` аргумент не указан, функция создаёт новый пустой кортеж `()` и возвращает ссылку на него.

:::info внимание

Определяющим признаком литерала кортежа является запятая, а не круглые скобки. Скобки необязательны, за исключением литерала пустого кортежа `()` или когда они необходимы во избежание синтаксической двусмысленности. Например, выражение `f(a, b, c)` — это вызов функции `f()` с тремя аргументами, а выражение `f((a, b, c))` — это вызов функции `f()` с одним аргументом — кортежем, состоящим из трёх элементов.

:::

Кортежи поддерживают все [стандартные операции](/docs/python-language/built-in-data-types/sequences/sequence-types) последовательностей.

В дополнение к кортежам в стандартной библиотеке Python предусмотрен дополнительный тип данных [`collections.namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) для хранения разнородных данных, доступ к которым по имени более удобен, чем по индексу.

## Инициализация кортежей {#tuple-initialization}

<CodeBlock language="python" title="tuples_1.py" showLineNumbers>{tuples_1}</CodeBlock>

В примере 1 на строке 3 создаётся пустой кортеж через литерал `()`.

На строке 7 через литерал создаётся кортеж, состоящий из одного элемента — строки `'a'`.

:::info внимание

При создании через литерал кортежа, состоящего из одного элемента, после единственного элемента обязательно должна стоять запятая. Иначе интерпретатор не распознает кортеж.

:::

Если бы на строке 7 не стояла запятая после `'a'`, интерпретатор счёл бы, что это инструкция создания строки `'a'`.

На строке 10 через литерал создаётся кортеж, состоящий из одного элемента — строки `'a'`. Элемент кортежа `'a'` заключён в круглые скобки, которые необязательны при объявлении кортежа. Круглые скобки применяются для наглядного обозначения границ кортежа. Вне зависимости от наличия или отсутствия скобок при объявлении через литерал кортежа, состоящего из одного элемента, после единственного элемента ставится запятая. Именно запятая является определяющим признаком литерала кортежа, если кортеж состоит из одного элемента.

На строке 13 приведён пример, иллюстрирующий тот факт, что если не поставить запятую после единственного элемента, литерал не будет распознан как кортеж, вне зависимости от наличия или отсутствия круглых скобок.  Выполняя инструкцию на строке 13, интерпретатор распознает литерал как строку, состоящую из одного символа `'a'`.

На строке 16 создаётся кортеж из одного элемента, являющегося строкой `'abcdef'`, так как после строки строит запятая, являющаяся признаком литерала кортежа.

На строке 19 создаётся кортеж из шести элементов. Каждый элемент — строка, состоящая из одного символа. Элементы отделяются друг от друга запятыми. При объявлении кортежа, состоящего более чем из одного элемента, завершающая запятая не обязательна.

На строке 22 записана та же инструкция, что и на строке 19, только кортеж заключён в круглые скобки. После последнего элемента можно также поставить запятую.

На строке 25 записана та же инструкция, что и на строке 22, только каждый элемент кортежа объявлен на новой строке. После последнего элемента можно также поставить запятую.

:::info внимание

Если элементы коллекции (под коллекциями понимаются последовательности, множества, словари и коллекции из стандартной библиотеки), заданной через литерал, сами заданы литералами строк (`str`) или литералами байт (`bytes`), и между ними не стоит запятая, интерпретатор Python воспринимает их как части одного элемента и автоматически объединяет (конкатенирует) в один элемент. Строки объединяются со строками, байты — с байтами, но нельзя объединять строки и байты (будет возбуждено исключение типа `SyntaxError` с сообщением: `SyntaxError: cannot mix bytes and nonbytes literals`). Со всеми другими типами отсутствие запятой между литералами возбудит исключение типа `SyntaxError` с сообщением: `SyntaxError: invalid syntax`.

:::

Например, можно записать так: `a = 'con' 'ca'   'tenation'`. Переменная `a` будет ссылаться на строку `'concatenation'`. Интерпретатору не важно, сколько пробелов находится между литералами строк, интерпретатор всё равно объединит их.

На строке 35 приводится пример, когда при задании кортежа запятые между строками `'b'` и `'c'`, а также между `'d'`, `'e'` и `'f'`. После выполнения этой инструкции будет создан кортеж из трёх элементов: `('a', 'bc', 'def')`.

На строке 38 приводится пример, аналогичный приведённому на строке 35, только каждый элемент кортежа задаётся на новой строке, и между литералами строк стоят не только пробелы, но и символы перевода строки. Интерпретатор воспринимает несколько таких идущих подряд литералов как один и выполняет конкатенацию.

**Нужно помнить** про эту особенность поведения интерпретатора при работе со строками и байтами. Если какая-то коллекция задана через литерал, элементами которого являются строки или байты, и будущем возможно добавление элементов в эту коллекцию, **рекомендуется ставить запятую после последнего элемента**, чтобы избежать ситуации, когда программист допишет ещё элемент в коллекцию и забудет поставить запятую, в результате чего программа будет работать не так, как ожидается. То есть вместо `a = ('a', 'b')` можно записать `a = ('a', 'b', )`, если программист предполагает, что в будущем придётся изменить программу и дописать в кортеж ещё элемент, чтобы получилось `a = ('a', 'b', 'c')`. Запятую между литералами очень легко пропустить, в частности, когда каждый новый элемент коллекции записывается на новой строке.

На строке 48 инициализируется пустой кортеж через вызов функции `tuple()` без аргументов.

На строке 51 инициализируется кортеж, состоящий из шести элементов, через вызов функции `tuple()` с аргументом — итерируемым объектом (в данном случае — строкой). Поскольку строки в Python — это последовательности символов, а значит, как любая последовательность — итерируемые объекты, функция `tuple()` принимает строку и инициализирует на кортеж на основе элементов этой строки. Поскольку функция `tuple()` может принимать любой итерируемый объект, кортежи можно создавать на основе любых последовательностей и итераторов, например, на основе списков или объектов типа `range` (диапазон).

<CodeBlock language="python" title="tuples_2.py" showLineNumbers>{tuples_2}</CodeBlock>

Пример 2 иллюстрирует способы создания через литералы кортежей, содержащих в качестве элементов другие коллекции, в свою очередь, тоже содержащие элементы.

На строках с 3 по 5 объявлен кортеж, состоящий из одного элемента — списка, состоящего, в свою очередь, из шести элементов — строк. Каждая строка состоит из одного символа.

:::info внимание

Литерал кортежа, состоящего из одного элемента, обязательно должен завершаться запятой. Именно наличие запятой подсказывает интерпретатору, что это кортеж, а не список, заключённый в скобки.

:::

На строках 6, 12 и 17 выполняется функция  [`type()`](https://docs.python.org/3/library/functions.html#type), возвращающая ссылку на тип данных передаваемого объекта, если она вызывается с одним аргументом. Функция `type()` на строке 6 возвращает тип данных, к которому относится кортеж `a` — `tuple`. На экран выводится строковое представление типа данных `tuple` — `<class 'tuple'>`.

На строках с 8 по 11 объявлен кортеж, состоящий из двух элементов — списков, каждый из которых состоит из шести элементов — строк. Каждая строка состоит из одного символа. В данном случае завершающая запятая не обязательна, так как кортеж `a` состоит более чем из одного элемента. На строке 12 функция `type()` возвращает тип данных `tuple`, и на экран выводится его строковое представление — `<class 'tuple'>`.

На строках с 14 по 16 приведён пример, когда из-за отсутствия завершающей запятой интерпретатор воспринимает литерал не как кортеж, состоящий из одного элемента, а как список (`list`), заключённый в круглые скобки. На строке 17 функция `type()` возвращает тип данных `list`, и на экран выводится его строковое представление — `<class 'list'>`.

## Обращение к элементам кортежей по индексам {#acessing-elements-of-tuples-by-indices}

В Python, как и в большинстве языков программирования (за исключением таких языков, как Lua, R и Julia), индексирование коллекций начинается с нуля. Например, если в индексируемой коллекции содержатся три элемента, их индексы будут `0`, `1` и `2`.

Понятие «индекс» в языках программирования тесно связано с понятием «смещение». Индексы обозначают смещение элементов от начала коллекции. Первый элемент не имеет смещения от начала коллекции (то есть его смещение равно нулю), поэтому индекс первого элемента равен `0`. Второй элемент смещён от начала коллекции на одну позицию, поэтому его индекс равен `1`. И так далее.

В Python обращение к элементам любых индексируемых коллекций (последовательностей, множеств) осуществляется через указание индекса коллекции в квадратных скобках. Например, обращение к первому элементу коллекции `a` (то есть элементу с нулевым смещением) осуществляется через выражение `a[0]`. В квадратных скобках может быть записано как целое число, так и выражение, вычисление которого даёт целое число. Например, выражение `a[len(a) - 1]` возвратит ссылку на последний элемент коллекции `a`, поскольку, выражение `len(a)` вернёт целое число, равное количеству элементов в коллекции `a`, а затем из этого числа будет вычтена единица, и будет получено число, равное индексу последнего элемента коллекции `a`. Если `a` содержит десять элементов, индекс последнего элемента будет равен `9`, так как отсчёт элементов начинается с нуля.

В Python также возможно обращение к элементам по индексам, имеющим отрицательные значения. К последнему элементу коллекции можно обратиться по индексу `-1`. При указании отрицательных чисел в качестве индексов интерпретатор вычисляет индексы, прибавляя эти отрицательные числа к длине коллекции. То есть выражение `a[-1]` равно выражению `a[-1 + len(a)]` и выражению `a[len(a) - 1]`.

<CodeBlock language="python" title="tuples_3.py" showLineNumbers>{tuples_3}</CodeBlock>

В примере 3 на строке 3 через вызов функции `tuple()` с аргументом (строкой) инициализируется кортеж, состоящий из шести элементов.

На строках с 6 по 11 выполняется обращение к элементам кортежа по индексам.

На строках с 13 по 18 выполняется обращение к элементам кортежа по индексам, имеющим отрицательное значение.

На строках с 20 по 25 интерпретатор вычисляет индексы, выполняя выражения, записанные внутри квадратных скобок. Поскольку выражения в скобках имеют наивысший приоритет, сначала вычисляются они, а потом выполняется обращение к индексам последовательности.

На строках с 27 по 30 через литерал создаётся кортеж из двух элементов. Элементы кортежа — тоже кортежи. Каждый вложенный кортеж состоит из трёх элементов.

На строках с 32 по 34 выполняется обращение ко всем трём элементам первого вложенного кортежа (имеющего индекс `0`), а на строках с 35 по 37 — ко всем трём элементам второго вложенного кортежа (имеющего индекс `1`). Интерпретатор вычисляет выражения в квадратных скобках слева направо. Сначала он находит элемент кортежа `a` по индексу в квадратных скобках, находящихся слева, затем внутри элемента находит элемент вложенного кортежа по индексу в квадратных скобках, находящихся правее.

На строках с 39 по 44 выполняется обращение ко вложенным элементам корежа по индексам, имеющим отрицательное значение.

На строках с 46 по 51 выполняется обращение ко вложенным элементам корежа по индексам, вычисленным в результате выполнения выражений, записанных внутри квадратных скобок. Этот пример демонстрирует, что можно вычислять индексы динамически.

На строках с 53 по 55 показана возможность обращения к элементам индексируемой последовательности в зависимости от условий, заданных в выражениях внутри квадратных скобок. На строке 53 объявлен кортеж из двух элементов. На строке 54 переменная `i` ассоциируется с целым числом, введённым с клавиатуры. На строке 55 выполняется условное выражение, в результате которого на экран выводится первый или второй элемент кортежа.

На строках 58 и 59 показано, что к элементам с индексами `0` и `1` можно обращаться, указывая в квадратных скобках соответствующие константы булева типа. Это возможно, поскольку булевы числа являются подтипом целых чисел.

На строке 62 показано, что индексы последовательностей не могут быть указаны числами с плавающей точкой. Они обязательно должны быть указаны целыми числами (включая булевы константы).

:::info внимание

Если какое-либо выражение, используемое для вычисления индекса, возвращает число с плавающей точкой, его нужно преобразовать в целое число, используя функцию `int()`, иначе интерпретатор возбудит исключение типа `TypeError`.

:::

## Распаковка кортежей: связывание элементов кортежей с переменными {#tuplesunpacking-bundling-elements-of-tuples-with-variables}

В Python имеется механизм, позволяющий автоматически переменные с элементами коллекций. Этот механизм называется распаковкой. Чаще всего распаковка используется совместно с кортежами (хотя таким же способом можно применять её, например, со строками и списками).

Как работает распаковка кортежей? Через литерал объявляется кортежа слева от оператора присваивания (`=`) и коллекция справа от оператора присваивания. Переменные, которые являются элементами кортежа, объявленного слева, связываются с элементами коллекции, объявленной справа. Кортеж, объявленный слева от оператора присваивания — это объект, заданный через литерал и сам не связанный ни с одной переменной. Он не используется в программе после того, как инициализирован. В программе используются только его элементы — переменные.

<CodeBlock language="python" title="tuples_4.py" showLineNumbers>{tuples_4}</CodeBlock>

В примере 4 на строке 3 литерал `a, b` — это кортеж, объявленный слева от оператора присваивания, а литерал `'one', 'two'` — кортеж, объявленный справа от оператора присваивания.

На строке 3 переменные `a` и `b` связываются с первым и вторым элементами кортежа `'one', 'two'`. Количество переменных (то есть количество элементов кортежа) слева от оператора присваивания должно совпадать с количеством элементов коллекции справа от оператора присваивания. Если количество переменных будет меньше или больше количества элементов кортежа, интерпретатор возбудит исключение типа `ValueError`, как показано на строках 6 и 7.

Можно связать сам распаковываемый кортеж с переменной. На строке 9 переменная `c` связывается с кортежем, заданным через литерал `a, b`, элементы которого, в свою очередь, связывается с элементами кортежа, заданного через литерал `'one', 'two'`.

Справа от оператора присваивания могут стоять индексируемые коллекции, например, строки и списки. На строке 12 элементы распаковываемого кортежа связываются с элементами строки `!?'`, состоящей из двух символов. На строке 15 распаковывается кортеж, элементы которого связываются с элементами списка `['one', 'two']`, содержащего две строки.

Распаковывать таким образом можно не только кортежи, но любые индексируемые упорядоченные коллекции, например списки. Вместо выражения `a, b = ['one', 'two']` на строке 15 можно было бы записать `[a, b] = ['one', 'two']`. Тогда вместо кортежа слева от оператора присваивания распаковывался бы список.

Часто распаковка кортежей применяется при вызове функций, когда требуется связать сразу несколько переменных с возвращаемыми объектами.

На строке 19 объявлена функция `test()`, принимающая последовательность и возвращающая кортеж, состоящий из первых трёх элементов последовательности.

На строке 24 переменные `a`, `b` и `c` связываются с первыми тремя элементами кортежа, созданного функцией `test()` на основе списка из шести элементов, переданного в качестве аргумента.

Программисту может быть заранее неизвестно количество элементов кортежа, который нужно распаковать. В этом случае применяется расширенный синтаксис со звёздочкой (`*`), записываемой слева от одной из переменных распаковываемого кортежа. Эта переменная будет ссылаться на список, содержащий элементы коллекции, объявленной справа от оператора присваивания, которые не поместятся в соседние элементы распаковываемого кортежа.

На строке 27 переменная `a` будет списком из шести элементов, а переменные `b` и `c` будут строками.

На строке 30 переменная `b` будет списком из шести элементов, а переменные `a` и `c` будут строками.

На строке 33 переменная `c` будет списком из шести элементов, а переменные `a` и `b` будут строками.

Если звёздочку поставить рядом более чем с одной переменной, интерпретатор возбудит исключение типа `SyntaxError` на этапе разбора кода, и программа не будет запущена.

На строке 36 приведён литерал `*a, *b, *c`, содержащий синтаксическую ошибку. Несмотря на то, что звёздочка стоит рядом с тремя переменными, интерпретатор после нахождения первых двух звёздочек выводит сообщение `SyntaxError: two starred expressions in assignment` и завершает работу.

Если в распаковываемом кортеже используется звёздочка, а коллекция, объявленная справа от оператора присваивания, содержит меньше элементов, чем переменных в распаковываемом кортеже, переменная со звёздочкой будет ссылаться на пустой список. Но в этом случае элементов в распаковываемом кортеже (переменных) может быть только на один больше, чем элементов в коллекции, объявленной справа, иначе будет возбуждено исключение типа `ValueError` с сообщением `ValueError: not enough values to unpack`.

На строке 38 в распаковываемом кортеже элементов больше на один, чем в кортеже справа от оператора присваивания. Переменная `a` в этом случае будет ссылаться на пустой список.

На строке 41 в распаковываемом кортеже элементов столько же, сколько в кортеже справа от оператора присваивания. Переменная `a` в этом случае будет ссылаться на список из одного элемента.

На строке 44 в распаковываемом кортеже на два элемента меньше, чем в кортеже справа от оператора присваивания. Если раскомментировать эту строку, будет возбуждено исключение типа `ValueError` с сообщением `ValueError: not enough values to unpack (expected at least 2, got 1)`.

Механизм распаковки кортежей Python позволяет переменным меняться ссылками на объекты.

На строке 46 элементы кортежа: `a, b` ссылаются на элементы кортежа `False, True`, на строке 49 переменные `a` и `b` меняются ссылками на объекты: переменная `a` теперь ссылается на объект, на который ранее ссылалась переменная `b`, и наоборот.

В функцию `print()` можно передавать переменные со звёздочкой, ссылающиеся на индексируемые коллекции. Тогда функция `print()` выведет элементы коллекции как отдельные аргументы.

На строках с 52 по 54 заданы три последовательности: строка `'abcdef'`, кортеж и список на основе этой строки.

На строках с 56 по 58 функция `print()` выводит эти последовательности целиком (аргументы без звёздочки), и по отдельности (аргументы со звёздочкой).

## Прохождение по элементам кортежей в цикле {#accessinge-elements-of-tuples-in-a-loop}

Можно проходить по индексируемым коллекциям, обращаясь к элементам напрямую, без использования объектов-итераторов. Для этого подходит цикл `while`. А можно воспользоваться более эффективным способом — проходить по элементам цикле `for`, который задействует механизм итераторов, о чём говорилось в секции **[Цикл for](/docs/python-language/compound-statements-beginning/for-statement)**.

<CodeBlock language="python" title="tuples_5.py" showLineNumbers>{tuples_5}</CodeBlock>

В примере 5 на строке 3 задан кортеж на основе строки.

На строках с 6 по 9 приводится пример прохождения по всем элементам индексируемой коллекции в цикле `while`. В цикле `while` происходит обращение к элементам индексируемой коллекции напрямую, без использования объекта-итератора. Переменная `i`, объявленная на строке 6, равна нулю, чтобы начальное значение переменной соответствовало индексу первого элемента кортежа. На строке 7 задаётся условие цикла. На каждой итерации цикла выполняются инструкции на строках 8 и 9:

- выводится строковое представление текущего элемента кортежа `a` — обращение к элементу происходит через выражение `a[i]`;
- переменная `i` увеличивается на единицу.

На строках с 18 по 21 показан пример прохождения по всем элементам индексируемой коллекции в обратном порядке, используя отрицательные индексы. Отсчёт начинается с `-1` и заканчивается на `-6`. На каждой итерации переменная `i` уменьшается на единицу.

:::info внимание

При прохождении по элементам цикла в прямом порядке в условии цикла используется оператор `>`, а при прохождении в обратном порядке в условии цикла используется оператор `>=`. Это связано с тем, что индексация в Python начинается с `0`, а не с `1`.

:::

Более эффективный способ прохождения по коллекциям — использование цикла `for`, использующего объекта-итератор, автоматически создаваемый на основе коллекции.

На строках 30 и 31 показан простейший способ обращения ко всем элементам коллекции. Этот способ работает как с индексируемыми, так и с неиндексируемыми коллекциями.

На строках 40 и 41 представлен способ прохождения по элементам коллекции в обратном порядке. Для этого используется встроенная функция [`reversed()`](https://docs.python.org/3/library/functions.html#reversed), возвращающая итератор, обращающийся к элементам коллекции в обратном порядке.

Часто возникают такие ситуации, когда может понадобиться доступ к счётчику итератора, который начинается с нуля, так же как и смещение индексируемых последовательностей. На каждой итерации счётчик итератора имеет то же значение, что и индекс текущего элемента. Для доступа к счётчикам итераторов в Python есть встроенная функция [`enumerate()`](https://docs.python.org/3/library/functions.html#enumerate), принимающая в качестве аргумента итерируемую коллекцию и возвращающая итератор. На каждой итерации цикла функция `enumerate()` возвращает кортеж из двух элементов: текущее значение счётчика и ссылка на элемент коллекции.

На строках 50 и 51 приведён пример прохождения по коллекции в цикле `for` с использованием функции `enumerate()`. Переменная `i` связывается со значением счётчика; переменная `e` связывается с элементом коллекции `a`. После каждой итерации счётчик `i` автоматически увеличивается на единицу. Поскольку и счётчик, и индексы коллекции начинаются с нуля, на каждой итерации цикла можно обратиться непосредственно к текущему элементу индексируемой коллекции по индексу, совпадающему с текущим значением счётчика: `a[i]` будет совпадать с `e`.

Функция `enumerate()` может принимать второй необязательный аргумент `start`, задающий начальное значение счётчика. Поэтому счётчик может начинаться с любого целого числа (положительного или отрицательного).

На строках 60 и 61 приведён пример прохождения по коллекции в цикле `for` с использованием функции `enumerate()` со счётчиком, начинающегося с `1`. Чтобы в процессе итерации обратиться напрямую к текущему элементу коллекции `a`, в данном примере используется выражение `a[i - 1]`, так как счётчик итератора на единицу больше, чем индекс текущего элемента коллекции.

На строках 70 и 71 приведён пример совместного использования функций `enumerate()` и `reversed()`. Функция `reversed()` возвращает итератор со ссылками на элементы коллекции `a`, отсортированными в обратном порядке коллекция отсортирована в обратном порядке. Функция `enumerate()` принимает в качестве аргумента ссылку на итератор, возвращённый функцией`reversed()` и, в свою очередь, возвращает собственный итератор с доступом к счётчику. На каждой итерации с переменной `i` связывается текущее значение счётчика итератора, возвращённого функцией `reversed()`, а с переменной `e` — ссылка на соответствующий элемент коллекции `a`.

На строках с 81 по 83 приведены примеры создания кортежей через вызов функции `tuple()` на основе объектов-итераторов, возвращаемых функциями `reversed()` и `enumerate()`.

## Обработка коллекций в цикле в зависимости от типов данных вложенных элементов {#processing-collections-in-a-loop-depending-on-the-data-types-of-nested-elements}

Ниже приведён пример того, как на Python можно за один вызов цикла обработать коллекцию с вложенными элементами, принадлежащими к разным типам данных. Для этого внутри цикла используется конструкция `if` и встроенная функция [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance).

Функция `isinstance()` принимает два аргумента: ссылку на объект и ссылку на тип данных, проверку на принадлежность к которому объекта нужно выполнить. Если объект принадлежит к этому типу данных, функция возвращает `True`. В противном случае возвращает `False`. Эта функция при проверке задействует механизмы объектно-ориентированного программирования. Более подробно эти механизмы будут разбираться в главе **Объектно-ориентированное программирование**.

Пример ниже показывает, как на Python просто и эффективно обрабатывать в циклах коллекции, содержащие элементы разных типов, в том числе коллекции с разной глубиной вложенности.

<CodeBlock language="python" title="tuples_6.py" showLineNumbers>{tuples_6}</CodeBlock>

В примере 6 на строке 4 задаётся кортеж `a` с пятью уровнями вложенности. На каждом уровне вложенности, кроме пятого, элементы кортежа являются строками или кортежами. На пятом уровне элементы являются только строками.

На строке 42 совершается обход всех элементов кортежа `a` в цикле `for`. Во время каждой итерации проверяется, является ли текущий элемент кортежем. Если является — запускается ещё один цикл `for`, обходящий все элементы этого элемента. В противном случае выводится строковое представление элемента с указанием его позиции внутри кортежа `a`. Так происходит на каждом уровне вложенности, кроме пятого. На пятом уровне вложенности выводится строковое представление всех элементов в цикле.

## Хеширование кортежей {#tuple-hashing}

Неизменяемые (иммутабельные) типы данных имеют такую характеристику, как хешируемость. В Python есть встроенная функция [`hash()`](https://docs.python.org/3/library/functions.html#hash), которая принимает неизменяемый объект и возвращает положительное или отрицательное целое число — хеш объекта. Хеши объектов, возвращаемые функцией `hash()`, подобны идентификаторам, возвращаемым функцией [`id()`](https://docs.python.org/3/library/functions.html#id) в том, что они не меняются, пока запущена программа и объект находится в оперативной памяти (при следующем запуске и хеши, и идентификаторы будут другими).

Разница межу хешами и идентификаторами заключается в том, что если во время выполнения программы удалить объект, а потом заново создать точно такой же объект, идентификаторы будут разными, а хеш будет один и тот же. Или если создать несколько объектов через одинаковые литералы, идентификаторы объектов будут разными, а хеш будет один и тот же. Идентификаторы нужны для проверки того, ссылаются ли переменные на один и тот же объект. Хеши нужны для проверки того, равны ли между собой неизменяемые объекты.

Изменяемые (мутабельные) объекты (такие, как списки, массивы байтов, множества, словари) не являются хешируемыми (поскольку они могут изменяться в процессе выполнения программы), и если передать изменяемый объект в функцию `hash()`, будет возбуждено исключение типа `TypeError` с сообщением `TypeError: unhashable type`.

Из этого следует вывод: если неизменяемая коллекция (например, кортеж), содержит хотя бы один элемент, являющийся изменяемой коллекцией (например, список), эта неизменяемая коллекция (контейнер) не является хешируемым. Хешируемыми являются не все неизменяемые коллекции, а только неизменяемые коллекции, содержащие неизменяемые элементы.

Хешируемые объекты можно использовать в качестве ключей таких изменяемых коллекций, как словари (`dict`). Об этом будет подробно написано в секции **[Словари](/docs/python-language/built-in-data-types/dictionaries)**.

<CodeBlock language="python" title="tuples_7.py" showLineNumbers>{tuples_7}</CodeBlock>

В примере 7 на строках 3, 8 и 13 объявлены три одинаковых кортежа `a`, `b` и `c`. Все три кортежа содержат по шесть элементов (строк, каждая из которых представлена одним символом). Все три кортежа равны между собой. Функция `print()` на строках 4, 9 и 14 выведет одно и то же строковое представление: `('a', 'b', 'c', 'd', 'e', 'f')`. Но это разные объекты. Функция `id()` на строках 5, 10 и 15 выведет разные идентификаторы. Функция `hash()` на строках 6, 11 и 16 выведет одно и то же целое число — одинаковые хеши этих кортежей.

На строке 18 выполняется проверка на идентичность (сравниваются идентификаторы объектов). Функция вернёт `False`.

На строке 19 сравниваются значения кортежей (сравниваются хеши объектов). Функция вернёт `True`.

Хотя функция `hash()` при проверках объектов возвращает одно и то же число, идентификаторы объектов-чисел разные. Но значения этих чисел одинаковые. Поэтому на строке 20 проверка на идентичность результатов вызовов функции `hash()` возвращает `False`, а проверка на равенство на строке 21 возвращает `True`.

На строке 23 создаётся кортеж `d` (неизменяемая последовательность), содержащий список (изменяемую последовательность). Попытка вычислить хеш кортежа `d` возбудит исключение типа `TypeError` с сообщением `TypeError: unhashable type: 'list'`.

На строках 27 и 30 демонстрируется изменяемость списка, являющегося элементом кортежа `d` (удаление первого элемента из списка на строке 27 и добавление нового элемента в список на строке 30).

После манипуляций со списком, ссылка на который является элементом кортежа `d`, идентификатор кортежа не поменяется (он вычисляется на строке 25 до изменений вложенного списка и на строке 33 после изменений вложенного списка).

На строке 35 объявлен кортеж `e`, элементами которого являются строка из одного символа, кортеж и неизменяемое множество. Поскольку все три вложенных элемента принадлежат к неизменяемым типам, хеширование такого кортежа возможно. На строке 41 возвращается хеш кортеже `e`.

## Коллекции на основе коллекций: вложенные элементы {#collections-based-on-collections-nested-elements}

Если создать коллекцию на основе другой коллекции, то элементы вновь созданной коллекции будут ссылаться на те же объекты, на которые ссылаются элементы исходной коллекции.

<CodeBlock language="python" title="tuples_8.py" showLineNumbers>{tuples_8}</CodeBlock>

В примере 8 на строке 3 создаётся список `a` из трёх элементов — пустых списков. На строке 7 создаётся кортеж `b` на основе списка `a`. Он будет содержать ссылки на те же три пустых списка, что и исходный список.

На строках 9 и 10 выводятся идентификаторы элементов списка `a` и идентификаторы кортежа `b` — для соответствующих элементов будут выведены одинаковые идентификаторы.

На строках с 12 по 14 в каждый вложенный список исходного списка `a` добавляется по одному элементу.

На строках 16 и 17 выводятся список `a` и кортеж `b` — оба они будут содержать изменённые списки, каждый из которых состоит из одного элемента.

## Операции с кортежами {#operations-on-tuples}

Ниже приведены операции с кортежами, поддерживаемые всеми последовательностями.

<CodeBlock language="python" title="tuples_9.py" showLineNumbers>{tuples_9}</CodeBlock>

В примере 9 на строке 3 объявлен кортеж `a`, состоящий из шести элементов, каждый из которых является строкой, состоящей из одного символа.

На строке 6 объявлена переменная `b`, ссылающаяся на строку `'b'`.

На строках 7 и 8 выполняется проверка вхождения строки, на которую ссылается переменная `b` в кортеж `a`. Интерпретатор проверяет, есть ли среди объектов, ссылки на которые хранятся в кортеже `a`, хотя бы один объект, равный строке `'b'` (проверка осуществляется путём сравнения значений объектов, а не идентификаторов). Если хотя бы один такой элемент есть в кортеже `a`, оператор `in` вернёт `True`, а оператор `not in` вернёт `False`. И наоборот, если нет ни одного такого элемента, оператор `in` вернёт `False`, а оператор `not in` вернёт `True`.

На строке 10 создаётся новый кортеж `c`, полученный путём конкатенации (объединения) кортежа `a`, и кортежа, объявленного через литерал.

На строках 13, 14 и 15 у кортежа `a` вычисляются:

- длина (количество элементов) — применяется функция `len()`;
- наименьшее значение среди элементов кортежа — применяется функция `(min)`;
- наименьшее значение среди элементов кортежа — применяется функция `(max)`.

Наименьшее и наибольшее значения получаются путём сравнения между собой элементов кортежа. Значения объектов, на которые ссылаются элементы коллекций, сравниваются между собой при помощи операторов `<` (в функции `min()`) и `>` (в функции `max()`). При нахождении минимального и максимального элементов коллекции элементы должны принадлежать к одному типу, иначе возбуждается исключение типа `TypeError`. Исключение — сравнение чисел разных типов, так объекты, принадлежащие к разным числовым типам, могут сравниваться между собой.

Подробнее о том, как сравниваются между собой элементы коллекций, можно подробнее почитать в официальной документации Python: [Sorting HOW TO](https://docs.python.org/3/howto/sorting.html#sortinghowto).

На строке 19 вызывается метод кортежа `tuple.index()`, возвращавший индекс первого найденного элемента, который равен переданному объекту. Перед вызовом метода `tuple.index()` желательно проверить, есть ли в коллекции элемент с таким значением, как показано на строке 18.

Если предварительно не выполнить проверку на наличие проверяемого элемента в коллекции, и окажется, что такого элемента нет, интерпретатор возбудит исключение типа `ValueError`.  Это произойдёт, если раскомментировать строку 20 и запустить программу.

На строках 22 и 23 выполняется метод `tuple.count()`, возвращающий целое число — количество элементов, чьё значение равно значению предаваемого объекта. Если элементов с таким же значением нет в коллекции, метод `tuple.count()` возвратит `0`.

На строках с 19 по 23 мы встречаемся с новой формой записи: вызовы методов объектов. Подробно о том, что такое методы, как их создавать, переопределять и вызывать, будет написано в главе **Объектно-ориентированное программирование**.

Упрощённо можно считать, что **методы — это функции объектов**. Имя метода отделяется от имени объекта точкой. Вызов метода объекта записывается так: `объект.метод()`.

На строках 25 и 28 приведены примеры, в которых создаются новые кортежи путём умножения исходных кортежей самих на себя. В результате такого умножения получается кортеж в которых элементы исходного кортежа повторяются несколько раз. Второй операнд должен быть целым числом. От порядка множителей результат не меняется. Если попытаться умножить кортеж на число с плавающей точкой, как показано на строке 30, будет возбуждено исключение типа `TypeError`.

На строках с 32 по 42 демонстрируется, что если кортеж содержит вложенные изменяемые коллекции (например, списки), кортеж, полученный в результате умножения исходного кортежа на самого себя, будет иметь в несколько раз больше ссылок на те же исходные объекты, ссылки на которые хранятся в исходном кортеже (смотрите пункт **[Коллекции на основе коллекций: вложенные элементы](#collections-based-on-collections-nested-elements)** выше).

Кортеж `a`, объявленный на строке 32, содержит в себе ссылки на два списка, каждый из которых состоит из трёх элементов. Кортеж `b` получен умножением кортежа `a` на три. Кортеж `b` хранит по три ссылки на каждый из двух исходных списков.

## Срезы кортежей {#tuple-slices}

Python позволяет не только обращаться по индексам к отдельным объектам, ссылки на которые хранятся в последовательностях, но и получать доступ сразу к нескольким элементам последовательности, используя синтаксис срезов (от английского «slice» — «срез»). Срез — это фрагмент последовательности. Он имеет тот же тип, что исходная последовательность. Например, срез кортежа будет кортежем, срез списка — списком, срез строки — строкой.

Полный синтаксис срезов: `последовательность[начало:конец:шаг]`.

Значения по умолчанию:

- начало — `0` (то есть оно равно нулевому смещению, которое имеет первый элемент последовательности);
- конец — целое число, равное количеству элементов последовательности (то есть оно равное смещению последнего элемента + 1);
- шаг — `1` (то есть между выбираемыми элементами нет интервала, и в срез попадают подряд все элементы, находящиеся в диапазоне от начала до конца среза).

Элемент последовательности, индекс которого равен начальному значению среза, включается в срез. Элемент последовательности, индекс которого равен конечному значению среза, не включается в срез.

Например, если есть кортеж `a = (0, 1, 2)`, срез `a[0:2]` вернёт кортеж `(0, 1)`, куда будет включён элемент с индексом `0`, но не будет включён элемент с индексом `2`. А срез `a[0:3]`, конечное значение которого равно длине исходного кортежа `a`, вернёт `(0, 1, 2)`, куда будут включён элемент с индексом `2`.

Это же правило действует при сортировке элементов в обратном порядке. Срезы `a[2:0:-1]` и `a[2:-3:-1]` вернут `(2, 1)`, а срез `a[2:-4:-1]` вернёт `(2, 1, 0)`.

Если шаг больше `1`, в срез попадают элементы, находящиеся друг от друга в указанном интервале. Шаг может быть отрицательным, тогда элементы выбираются в обратном порядке. В этом случае начальное значение среза должно быть больше, чем конечное значение.

Поддерживается также сокращённый синтаксис без указания шага: `последовательность[начало:конец]`.

Выражения `последовательность[::]` и `последовательность[:]` вернут срез, равный всей последовательности, так как в этих выражениях задействованы значения по умолчанию. То же самое вернёт срез `последовательность[::1]`.

Выражение `последовательность[::-1]` вернёт срез, равный всей последовательности, с элементами, выбранными в обратном порядке.

Возможные варианты записи срезов:

- `последовательность[начало:]` или `последовательность[начало::]` — срез от указанного значения до конца последовательности;
- `последовательность[:конец]` или `последовательность[:конец:]` — срез от начала последовательности до указанного значения;
- `последовательность[начало::шаг]`  — срез от указанного значения до конца последовательности с указанным шагом (если шаг отрицательный — отсчёт идёт в обратном порядке от указанного значения до начала последовательности);
- `последовательность[:конец:шаг]` — срез от начала последовательности до указанного значения с указанным шагом (если шаг отрицательный — отсчёт идёт в обратном порядке от конца последовательности до указанного значения);
- `последовательность[::шаг]` — срез от начала до конца последовательности с указанным шагом (если шаг отрицательный — отсчёт идёт в обратном порядке от конца до начала последовательности).

<CodeBlock language="python" title="tuples_10.py" showLineNumbers>{tuples_10}</CodeBlock>

В примере 10 на строке 3 создаётся кортеж `a` из десяти элементов. Каждый элемент кортежа — целое число, соответствующее индексу этого элемента.

На строке 7 задаётся начальное значение вспомогательной переменой `i`, равное `0`. На строках с 8 по 10 в цикле `while` выводятся все элементы кортежа `a` с указанием индексов. Переменная `i` увеличивается на единицу на каждой итерации.

Начиная со строки 25 демонстрируется взятие срезов.

На строках 25, 27 и 29 берутся срезы, равные исходной последовательности. На строке 25 явно указаны начало и конец среза. На строке 27 явно указано только начало среза. На строке 29 все значения среза берутся по умолчанию.

Если срез равен последовательности, и последовательность изменяемая — возвращается поверхностная копия исходной последовательности. Если срез равен последовательности, и последовательность неизменяемая — возвращается ссылка на исходную последовательность.

На строках 26, 28 и 30 выражения `s is a` возвращают `True`. Это значит, что переменная `s` (срез) ссылается на тот же объект, что переменная `a`, и у среза и исходно последовательности один и тот же идентификатор. На строках 26, 28 и 30 выражения `s is a` возвращают `True`, поскольку `a` — неизменяемая последовательность — кортеж, и поэтому при взятии среза `s`, равного исходной последовательности, возвращается ссылка на исходную последовательность.

На строке 33 берётся срез, включающий элементы первой половины последовательности `a`. Начало среза берётся по умолчанию, а конец среза, заданный выражением `len(a) // 2`, равен целому числу `5`.

На строке 35 аналогичным способом берётся срез, включающий элементы второй половины последовательности `a`. Начало среза, заданное выражением `len(a) // 2`, равно целому числу `5`, а конец среза берётся по умолчанию.

Срезы всегда относятся к тому же типу данных, что и исходная последовательность.

На строках 34 и 36 выполняется функция [`type()`](https://docs.python.org/3/library/functions.html#type), возвращающая ссылку на тип данных передаваемого объекта, если она вызывается с одним аргументом. Функция `type()` на строках 34 и 36 возвращает тип данных, к которому относятся срезы `s` — `tuple`. На экран выводится строковое представление типа данных `tuple` — `<class 'tuple'>`.

На строках 39, 41, 43 и 45 приводятся примеры взятия срезов с указанием положительных чисел для обозначения границ срезов. Срезы на строках 39, 41 и 43 будут иметь по два элемента. Срез на строке 45 будет иметь один элемент.

На строках 49 и 51 приводятся примеры взятия пустых срезов. Пустые срезы получаются потому что в пределах границ нет ни одного элемента исходной последовательности.

На строке 55 задаётся начальное значение вспомогательной переменой `i`, равное `-10`. На строках с 56 по 58 в цикле `while` выводятся все элементы кортежа `a` с указанием индексов, заданных отрицательными числами. Переменная `i` уменьшается на единицу на каждой итерации.

На строках 72, 74, 76, 78 и 80 приводятся примеры взятия срезов с указанием отрицательных чисел для обозначения границ срезов. Срезы на строках 72, 74, 76 и 80 будут иметь по два элемента. Срез на строке 78 будет пустым.

:::info внимание

На строке 80 в качестве начала среза указано число `-20`. Это смещение находится за границами последовательности. Однако Python позволяет указывать границы срезов, находящиеся за пределами исходных последовательностей. В таких случаях интерпретатор начинает отсчёт от границ последовательностей.

:::

На строках 84, 86, 88 и 90 приведены примеры срезов с разной длиной шага, где шаг задан положительным числом, поэтому включение элементов в срез выполняется слева направо (прямой порядок).

На строках 94, 96 и 98 приведены примеры срезов с разной длиной шага, где шаг задан отрицательным числом, поэтому включение элементов в срез выполняется справа налево (обратный порядок).

На строках 103, 105, 107, 109 и 111 приведены примеры срезов, в которых используются комбинации положительны и отрицательных чисел для обозначения границ срезов и указания шага.

:::info внимание

Если предполагается, что в срез должен попасть хотя бы один элемент исходной последовательности, при шаге, заданном положительным числом, начальное смещение исходной последовательности должно быть меньше конечного смещения, так как включение элементов в срез выполняется слева направо (прямой порядок). И наоборот, при шаге, заданном отрицательным числом, начальное смещение исходной последовательности должно быть больше конечного смещения, так как включение элементов в срез выполняется справа налево (обратный порядок). При этом совершенно не важно, положительными или отрицательными числами указаны границы среза.

:::

Как было сказано выше, Python позволяет обращаться к элементам последовательностей по индексам, заданным булевыми константами `True` и `False`, поскольку булевы числа являются подтипом целых чисел. Также было сказано, что индексы нельзя задавать с помощью чисел с плавающей точкой. Это же справедливо для срезов.

На строке 115 приведён пример среза, где начальная граница и шаг указаны булевыми числами.

На строках 117 и 118 приводятся примеры того, что если указать в качестве границ или шага среза числа с плавающей точкой, интерпретатор возбудит исключение типа `TypeError`. Поэтому если для вычисления границ или шага используются выражения, всегда нужно следить, чтобы они возвращали целые числа. При необходимости можно преобразовать результат вычисления к целому числу функцией `int()`.

На строке 121 приведена иллюстрация того, что шаг среза не может быть равен нулю. Если шг будет равен нулю, интерпретатор возбудит исключение типа `ValueError`.

На строках 124—125 и 132—133 приводятся примеры прохождения по срезам в цикле `for`. Поскольку срез — это последовательность, работа со срезами в циклах ничем не отличается от работы с последовательностями.

:::info внимание

Индексы элементов в срезе, так же как в любой последовательности, начинаются с нуля и образуют ряд целых чисел. Поэтому, если срез не равен исходной последовательности, индексы элементов среза не будут совпадать с индексами элементов последовательности, попавшими в срез. Индексы среза будут совпадать со значениями счётчика итератора `enumerate` (при условии, что при вызове функции `enumerate()` аргумент `start` имел значение по умолчанию — `0`).

:::

На строке 140 приводится пример получения кортежа на основе объекта типа `enumerate`, полученного на основе среза `a[-1:-11:-3]`. То же самое работает с любыми последовательностями.

На строке 144 приведён пример взятия среза со среза. Это работает, но практического смысла в этом нет, так как можно взять сразу нужный срез с исходной последовательности, чем использовать промежуточный срез и брать срез с него.

На строках 147 и 157 показывается в деталях, как работает инструкция `a[::2][::2]`, приведённая на строке 144. Сначала выполняется выражение в квадратных скобках, находящееся слева — получается срез из трёх элементов. Индексы полученного кортежа, как и у любой другой последовательности, начинаются с нуля. Затем выполняется выражение в квадратных скобках, находящееся справа, берущее срез от кортежа, полученного в результате взятия первого среза. Во второй срез попадают первый, третий и пятый элементы первого среза. Они, соответственно, становятся первым, вторым и третьим элементами второго среза.

## Дополнительные ссылки {#additional-links}

- [Кортеж (информатика)](https://ru.wikipedia.org/wiki/Кортеж_(информатика))
- [Смещение (информатика)](https://ru.wikipedia.org/wiki/Смещение_(информатика))
- [Ошибка на единицу](https://ru.wikipedia.org/wiki/Ошибка_на_единицу)
- [Хеш-функция](https://ru.wikipedia.org/wiki/Хеш-функция)
- [Конкатенация](https://ru.wikipedia.org/wiki/Конкатенация)
- [Конструктор (объектно-ориентированное программирование)](https://ru.wikipedia.org/wiki/Конструктор_(объектно-ориентированное_программирование))
