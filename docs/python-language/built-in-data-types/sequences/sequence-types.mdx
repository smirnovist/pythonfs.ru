---
sidebar_position: 1
---

# Типы последовательностей

## Общая информация {#common-information}

Последовательность — это **индексируемая** коллекция, то есть коллекция (или контейнер) объектов, к которым можно обратиться по индексам. Индекс — это целое число, обозначающее смещение элемента от начала последовательности (положительные индексы) или от конца последовательности (отрицательные индексы).

Последовательности бывают изменяемые, или мутабельные (от английского «mutable» — «изменяемый») и неизменяемые, или иммутабельные (от английского «immutable» — «неизменяемый»).

Изменяемые последовательности — это:

- списки (`list`);
- массивы байтов (`bytearray`);
- объекты для доступа внутренним данным объектов, поддерживающих буферный протокол (`memoryview`);

Неизменяемые последовательности — это:

- кортежи (`tuple`);
- строки(`str`);
- байты (`bytes`);
- диапазоны (`range`).

### Таблица 1. Операции, поддерживаемые всеми последовательностями {#table-1-common-sequence-operations}

Операции в следующей таблице поддерживаются большинством типов последовательностей, как изменяемых, так и неизменяемых. В модуле [`collections.abc`](https://docs.python.org/3/library/collections.abc.html) стандартной библиотеки предусмотрен абстрактный базовый класс [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence), чтобы обеспечить программистам удобную возможность создания собственных типов последовательностей, поддерживающих базовые операции с последовательностями.

В таблице 1 перечислены операции с последовательностями, отсортированные по возрастанию приоритета. В таблице `s` и `t` — это последовательности одного типа, `n`, `i`, `j` и `k` — целые числа, а `x` — произвольный объект, который соответствует любым ограничениям типа и значения, налагаемым последовательностью `s`.

Операции `in` и `not in` имеют те же приоритеты, что операции сравнения. Операции `+` (конкатенация) и `*` (повторение) имеют тот же приоритет, что и соответствующие числовые операции.

| Операция | Результат | Примечания |
| -------- | --------- | ---------- |
| `x in s` | `True`, если `x` равен какому-либо элементу последовательности `s`, иначе `False` | 1 |
| `x not in s` | `True`, если `x` не равен ни одному элементу последовательности `s`, иначе `False` | 1 |
| `s + t` | Конкатенация последовательностей `s` и `t` (прибавление последовательности `t` к последовательности `s`) | 6, 7 |
| `s * n` или `n * s` | Эквивалент прибавления всех элементов последовательности `s` к самой себе `n` раз | 2, 7 |
| `s[i]` | Обращение к `i`-му элементу последовательности `s`, начиная с `0` | 3 |
| `s[i:j]` | Взятие среза последовательности `s` от `i` до `j` | 3, 4 |
| `s[i:j:k]` | Взятие среза последовательности `s` от `i` до `j` с шагом `k` | 3, 5 |
| [`len(s)`](https://docs.python.org/3/library/functions.html#len) | Длина (количество элементов) последовательности `s` | |
| [`min(s)`](https://docs.python.org/3/library/functions.html#min) | Наименьший элемент последовательности `s` | |
| [`max(s)`](https://docs.python.org/3/library/functions.html#max) | Наибольший элемент последовательности `s` | |
| `s.index(x[, i[, j]])` | Индекс первого вхождения `x` в последовательности `s` (поиск ведётся в диапазоне от индекса `i`, включая сам индекс `i`, до индекса `j`, не включая сам индекс `j`) | 8 |
| `s.count(x)` | Общее количество вхождений элемента `x` в последовательности `s` | |

Последовательности одного типа также поддерживают сравнения. В частности, кортежи и списки сравниваются лексикографически путем сравнения соответствующих элементов. Это означает, что две последовательности равны, если соблюдены следующие условия:

- обе последовательности принадлежат к одному типу;
- обе последовательности и имеют одинаковую длину (одинаковое количество элементов);
- соответствующие элементы обеих последовательностей равны между собой.

Если не соблюдено хотя бы одно из условий, две последовательности не равны.

Операторы сравнения представлены в главе **[Операторы](/docs/python-language/operators)**.

### Примечания к таблице 1 {#notes-to-table-1}

1. Несмотря на то, что операторы `in` и `not in` обычно используются для простой проверки наличия одиночных элементов в последовательностях, их можно использовать для тестирования наличия подпоследовательностей (групп элементов) в таких специализированных последовательностях, как строки (`str`), байты (`bytes`) и массивы байтов (`bytearray`). Например, строки являются последовательностями, состоящими из символов. Один символ — один элемент. Подстрока в строке — это подпоследовательность элементов (группа символов) в последовательности. С помощью операторов  `in` и `not in` можно проверять наличие подстрок в строках:

    ```python showLineNumbers
    >>> "gg" in "eggs"
    True
    ```

2. Значения `n`, меньшие `0`, приравниваются к `0`, и в этом случае результатом операции `*` будет пустая последовательность того же типа, что и `s`). **Обратите внимание,** что при выполнении операции `*` исходные элементы последовательности *s* не копируются, а передаются по ссылке несколько раз. В результате получается последовательность, в `n` раз большая, чем исходная `s`, но количество объектов, на которые ссылаются элементы полученной последовательности, остаётся прежним. Например, если список, содержащий в себе другой пустой список, умножить на `3`, мы получим список из трёх элементов, каждый из которых будет ссылаться на тот же исходный пустой список. Изменение любого элемента полученного списка изменяет этот единственный исходный список:

    ```python showLineNumbers
    >>> lists = [[]] * 3
    >>> lists
    [[], [], []]
    >>> lists[0].append(3)
    >>> lists
    [[3], [3], [3]]
    ```

    Создать список из разных списков можно следующим образом:

    ```python showLineNumbers
    >>> lists = [[] for i in range(3)]
    >>> lists[0].append(3)
    >>> lists[1].append(5)
    >>> lists[2].append(7)
    >>> lists
    [[3], [5], [7]]
    ```

    Более подробно операция `*` со списками рассмотрена в подсекции **[Списки](/docs/python-language/built-in-data-types/sequences/lists)**. Также можно получить информацию в разделе FAQ официальной документации по Python: [How do I create a multidimensional list?](https://docs.python.org/3/faq/programming.html#faq-multidimensional-list).

3. Если `i` или `j` — отрицательные числа, индекс отсчитывается относительно конца последовательности `s`. Их можно рассматривать как выражения `len(s) + i` или `len(s) + j`. Но следует помнить, что `-0` (отрицательный ноль) — это тоже `0`.
4. Срез последовательности `s` от `i` до `j` определяется как последовательность элементов с индексами `k`, для каждого из которых соблюдается условие`i <= k < j`.  Если `i` или `j` больше чем `len(s)`, вместо него подставляется `len(s)`.  Если `i` пропущено или равно `None`, вместо него подставляется `0`.  Если `j` не указано или равно `None`, вместо него подставляется `len(s)`.  Если`i >= j`, возвращается пустой срез.
5. Срез последовательности `s` от `i` до `j` с шагом `k` определяется как последовательность элементов с индексами `x`, для каждого из которых соблюдается два условия: `x = i + n*k` и `0 <= n < (j-i)/k`.  Другими словами, это индексы `i`, `i+k`, `i+2*k`, `i+3*k` и так далее, и эта последовательность заканчивается, когда достигнуто `j` (но само `j` не включается).  Если `k` — положительное число, и если `i` и `j` больше, чем `len(s)`, вместо них подставляется `len(s)`. Если `k` — отрицательное число, и если  `i` и `j` больше, чем `len(s) - 1`, вместо них подставляется `len(s) - 1`.  Если `i` или `j` не указаны или равны `None`, они становятся конечными значениями (конец зависит от знака `k`).  Следует учесть, что `k` не может быть равно `0`. Если `k` равно `None`, вместо него подставляется `1`.
6. Операция объединения неизменяемых последовательностей всегда возвращает ссылку на новый объект. Это означает, что при создании последовательности путём повторной конкатенации время выполнения операции будет иметь квадратичную зависимость от общей длины последовательности. Чтобы получить линейную зависимость времени выполнения от длины последовательности, нужно использовать одну из следующих альтернатив:
    - при объединении объектов типа `str` (строки) можно создать список (`list`) и использовать метод `str.join()` в конце обработки или записать строки в экземпляр класса `io.StringIO` и получить его значение по завершении обработки;
    - при конкатенации объектов типа `bytes` (байты) можно аналогичным образом использовать метод `bytes.join()` или объект `io.StringIO`, или можно выполнять множественную конкатенацию с объектом `bytearray` (массив байт). Объекты `bytearray` изменяемые и имеют эффективный механизм увеличения последовательности.
    - при объединении объектов `tuple` (кортеж) вместо этого можно увеличивать объект `list` (список);
    - для других типов следует изучить соответствующую документацию классов.
7. Некоторые типы последовательностей, например, `range` (диапазон), поддерживают только последовательности элементов, которые следуют определенным шаблонам, и, следовательно, не поддерживают конкатенацию или повторение последовательностей.
8. Метод `index()` возбуждает исключение типа `ValueError`, если `x` не находится в `s`. Не все реализации интерпретатора Python поддерживают передачу дополнительных аргументов `i` и `j`. Эти аргументы позволяют эффективно искать части последовательности. Передача дополнительных аргументов примерно эквивалентна использованию выражения `s[i:j].index(x)`, только без копирования каких-либо данных, и возвращаемый индекс будет относиться к началу последовательности, а не к началу среза.

### Таблица 2. Операции, поддерживаемые изменяемыми типами последовательностей {#table-2-mutable-sequence-operations}

В таблице 2 приводятся операции, поддерживаемые изменяемыми типами последовательностей. Для упрощения правильной реализации этих операций с пользовательскими типами последовательностей в стандартной библиотеке реализован абстрактный базовый класс [`collections.abc.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence).

В таблице `s` — это экземпляр последовательности изменяемого типа, `t` — любой итерируемый объект (либо сама последовательность, либо объект-итератор, созданный на основе последовательности), `x` — произвольный объект, который соответствует любым ограничениям типа и значения, налагаемым типом последовательности `s` (например, последовательность типа `bytearray` (массив байтов) принимает только целые числа `x`, которые соответствуют ограничению `0 <= x <= 255`).

| Операция | Результат | Примечания |
| -------- | --------- | ---------- |
| `s[i] = x` | Замена `i`-го элемента последовательности `s` на объект `x` | |
| `s[i:j] = t` | Замена среза последовательности `s` от `i` до `j` на содержимое итерируемого объекта `t` | |
| `del s[i:j]` | Удаление среза  `s[i:j]` (то же, что `s[i:j] = []`) | |
| `s[i:j:k] = t`  | Замена среза `s[i:j:k]` итерируемым объектом `t` | 1 |
| `del s[i:j:k]` | Удаление элементов среза `s[i:j:k]` из последовательности `s` | |
| `s.append(x)` | Добавление `x` в конец последовательности `s` (то же, что `s[len(s):len(s)] = [x]`) | |
| `s.clear()` | Удаление всех элементов последовательности `s` (то же, что `del s[:]`) | 5 |
| `s.copy()` | Создание поверхностной копии последовательности `s` (то же, что `s[:]`) | 5 |
| `s.extend(t)`<br />или<br />`s += t` | Расширение последовательности `s` путём прибавления содержимого последовательности `t` (по большей части то же, что `s[len(s):len(s)] = t`) | |
| `s *= n` | Обновление последовательности `s`  её собственным содержимым, повторённым `n` раз | 6 |
| `s.insert(i, x)` | Вставка `x` в последовательность `s` по индексу, заданному `i` (то же, что `s[i:i] = x`) | |
| `s.pop()`<br />или<br />`s.pop(i)` | Извлечение `i`-го элемента и одновременное удаление его из последовательности `s` | 2 |
| `s.remove(x)` | Удаление первого вхождения объекта `x` из последовательности `s` | 3 |
| `s.reverse()` | Сортировка последовательности `s` в обратном порядке | 4 |

### Примечания к таблице 2 {#notes-to-table-2}

1. Итерируемый объект `t` должен иметь ту же длину, что и заменяемый срез.
2. Необязательный аргумент `i` по умолчанию равен `-1`, поэтому по умолчанию удаляется и возвращается последний элемент последовательности.
3. Метод `remove()` возбуждает исключение типа`ValueError`, если объект `x` не найден в последовательности `s`.
4. Метод `reverse()` сортирует исходную последовательность в обратном порядке, не создавая её копии в оперативной памяти ради экономии вычислительных ресурсов при обработке больших последовательностей. Метод не возвращает отсортированную последовательность, чтобы напомнить программисту, что в результате вызова метода возникает побочный эффект.
5. Методы `clear()` и `copy()` добавлены для обеспечения согласованности (консистентности) с интерфейсами изменяемых контейнеров, которые не поддерживают операции взятия срезов (например, `dict` (словарь) и `set` (множество)). Метод `copy()` не является частью абстрактного базового класса [`collections.abc.MutableSequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence), но большинство конкретных классов изменяемых последовательностей предоставляют его.
6. Значение `n` является целым числом или объектом, реализующим служебный метод `__index__()`. Нулевые и отрицательные значения `n` очищают последовательность (удаляет все элементы последовательности). При умножении последовательности самой на себя элементы не копируются, на них несколько раз создаются ссылки, как было объяснено в примечании к операции `s * n` (примечание 2 к таблице 1).

## Неизменяемые типы последовательностей {#immutable-sequence-types}

Единственная операция, которая обычно реализуется неизменяемыми типами последовательностей и не реализуется изменяемыми типами последовательностей, — это поддержка встроенной функции [`hash()`](https://docs.python.org/3/library/functions.html#hash).

Эта поддержка позволяет использовать неизменяемые последовательности, такие как объекты типа `tuple` (кортежи), в качестве ключей объектов типа `dict` (словари) и хранить их в объектах типа `set` (множества) и `frozenset` (неизменяемые множества).

Попытка хешировать неизменяемую последовательность, содержащую нехешируемые значения, приведёт к возбуждению исключения `TypeError`.

## Дополнительные ссылки {#additional-links}

- [Изменяемый тип](https://ru.wikipedia.org/wiki/Изменяемый_тип)
- [Неизменяемый объект](https://ru.wikipedia.org/wiki/Неизменяемый_объект)
- [Immutable object](https://en.wikipedia.org/wiki/Immutable_object)
- [Конкатенация](https://ru.wikipedia.org/wiki/Конкатенация)
- [Побочный эффект (программирование)](https://ru.wikipedia.org/wiki/Побочный_эффект_(программирование))
- [Согласованность данных](https://ru.wikipedia.org/wiki/Согласованность_данных)
