---
sidebar_position: 1
---

import CodeBlock from '@theme/CodeBlock';
import if_statement_1 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_1.py';
import if_statement_2 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_2.py';
import if_statement_3 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_3.py';
import if_statement_4 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_4.py';
import if_statement_5 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_5.py';
import if_statement_6 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_6.py';
import if_statement_7 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_7.py';
import if_statement_8 from '!!raw-loader!/static/examples/python-language/compound-statements-beginning/if-statement/if_statement_8.py';

# Условная конструкция if

Допустим, нам нужно выполнить что-то в зависимости от заданных условий. Тут нам пригодится условная конструкция `if`.

Условная конструкция `if` содержит условие, обозначенное ключевым словом `if` (от английского «if» — «если») и логический блок кода (набор инструкций для выполнения, сам являющийся составной инструкцией). Логический блок кода оформляется отступом, который равен четырём пробелам (внутри блока могут быть вложенные блоки кода, и тогда они оформляются дополнительными отступами).

Условная конструкция `if` работает по алгоритму: если выполняется заданное условие (то есть если преобразование к булеву типу заданного выражения возвращает ссылку на константу `True`) — выполнить блок кода.

```python showLineNumbers
# Объявление условной конструкции
if a == 1:    # Условие
    pass      # Логический блок, выполняемый, если условие истинно
```

Одним из следствий позиционного синтаксиса Python является невозможность использования пустых блоков кода в условных конструкциях. Если нужно, чтобы при выполнении какого-то условия интерпретатор не выполнял никаких инструкций, используется инструкция `pass` (от английского «pass» — «пропускать»). Если оставить блок кода пустым, при разборе кода на синтаксические конструкции (до этапа выполнения) будет возбуждено исключение типа `IndentationError` с сообщением: `IndentationError: expected an indented block`.

В условной конструкции может быть задано несколько условий. Второе и последующие условия задаются ключевым словом `elif`. Интерпретатор проверяет условия одно за другим, выполняя выражения, относящиеся к логическим блокам. Если преобразование к булеву типу выражения в условии вернёт ссылку на константу `True`, интерпретатор выполняет блок кода, относящийся к этому условию, и не проверяет следующие условия.

```python showLineNumbers
# Объявление условной конструкции
if a == 1:    # Первое условие
    pass      # Логический блок, выполняемый, если первое условие истинно
elif a == 2:  # Второе условие
    pass      # Логический блок, выполняемый, если второе условие истинно, а первое — ложно
```
В конце условной конструкции может быть задан блок кода, который должен выполняться, если ни одно предыдущее условие не было выполнено (то есть если все выражения в условиях в результате преобразования к булеву типу вернули ссылки на константу `False`). Этот блок кода задаётся ключевым словом `else` (от английского «else» — «иначе, в противном случае»):

```python showLineNumbers
# Объявление условной конструкции
if a == 1:    # Первое условие
    pass      # Логический блок, выполняемый, если первое условие истинно
elif a == 2:  # Второе условие
    pass      # Логический блок, выполняемый, если второе условие истинно, а первое — ложно
else:         # Условие, выполняемое, если ложными являются все условия, объявленные выше
    pass      # Логический блок, выполняемый, если ложными являются все условия, объявленные выше
```

<CodeBlock language="python" title="if_statement_1.py" showLineNumbers>{if_statement_1}</CodeBlock>

Рассмотрим пример 1.

В этом примере на строках 4 и 5 объявлен ввод строки с клавиатуры и преобразование её к целому числу, на которое ссылается переменная `a`. На строке 8 объявлена условная конструкция. На строке 19 объявлена инструкция, выводящая строковое представление объекта, на который ссылается переменная `a`. Инструкция на строке 19 не зависит от результата выполнения условной инструкции. Это видно из того, что она расположена на нулевом уровне вложенности (то есть не имеет отступов слева). Если сдвинуть инструкцию вправо на один отступ (четыре пробела), инструкция на строке 19 будет относиться к логическому блоку, следующему за ключевым словом `else`.

При выполнении условной конструкции на строке 8 интерпретатор проверяет число, на которое ссылается переменная `a`, на равенство числу `1`. Если `a` равно `1` (то есть выражение `a == 1` вернёт ссылку на константу `True`), выполняется инструкция на строке 9, после чего интерпретатор завершит выполнение условной конструкции и сразу перейдёт к выполнению инструкции на строке 19. В противном случае (то есть если выражение `a == 1` вернёт ссылку на константу `False`), интерпретатор перейдёт к проверке на строке 10.

Если выражение `a == 2` на строке 10 вернёт ссылку на константу `True`, интерпретатор выполнит инструкцию на строке 11 и перейдёт к выполнению инструкции на строке 19. В противном случае (то есть если выражение `a == 2` вернёт ссылку на константу `False`), интерпретатор перейдёт к проверке на строке 12.

Если выражение `a == 3` на строке 12 вернёт ссылку на константу `True`, интерпретатор выполнит инструкцию на строке 13 и перейдёт к выполнению инструкции на строке 19. В противном случае (то есть если выражение `a == 3` вернёт ссылку на константу `False`), интерпретатор перейдёт к выполнению инструкции на строке 15, а затем выполнит инструкции на строке 19, которая не связана с условной конструкцией.

<CodeBlock language="python" title="if_statement_2.py" showLineNumbers>{if_statement_2}</CodeBlock>

Код в примере 2 работает почти так же, как в примере 1. Разница лишь в том, что в примере 2 применяются операторы сравнения `>` и `<` в сочетании с логическим оператором `and`, а в примере 1 применяется оператор сравнения `==`. Благодаря разным приоритетам операторы сравнения и логические операторы можно записывать в одном выражении без скобок, о чём говорилось в главе **[Операторы](/docs/python-language/operators)**.

<CodeBlock language="python" title="if_statement_3.py" showLineNumbers>{if_statement_3}</CodeBlock>

Код в примере 3 работает так же, как в примере 2. Запись условий в примере 3 является упрощённым вариантом записи условий из примера 2. Возможность использовать операторы сравнения по цепочке и выполнять проверки слева направо позволяет избежать употребления логического оператора `and`.

<CodeBlock language="python" title="if_statement_4.py" showLineNumbers>{if_statement_4}</CodeBlock>

Выше было написано, что если выражение в условии вернёт ссылку на константу `True`, интерпретатор выполняет блок кода, относящийся к этому условию, и не проверяет следующие условия. Пример 4 иллюстрирует это утверждение.

На строке 5 выполняется проверка `a == 1`. Поскольку выражение `a == 1` на строке 6 возвращает `True`, выполняется инструкция на строке 7, связывающая переменную `a` с целочисленным объектом `2`. После этого обработка условной конструкции завершается, и интерпретатор переходит к выполнению инструкции на строке 11. Несмотря на то, что `a` после выполнения инструкции на строке 7 становится равным `2`, вторая проверка на строке 8 не выполняется, так как первая проверка на строке 6 вернула `True`.

## Проверка объектов на истинность в условных конструкциях {#checking-objects-for-true-in-conditional-constructs}

<CodeBlock language="python" title="if_statement_5.py" showLineNumbers>{if_statement_5}</CodeBlock>

Пример 5 иллюстрирует проверку объекта, связанного с переменной, на истинность.

На строке 7 вместо выражения `if bool(a) is True` используется сокращённая запись `if a`. Поскольку при проверке условий выполняется преобразование результатов вычислений к булеву типу, такая запись корректна и считается хорошей практикой.

На строке 15 вместо выражения `if bool(a and b) is True` используется сокращённая запись `if a and b`. Выражение `a and b` возвращает или `a`, или `b`, возвращённый объект проверяется на истинность при проверке условия.

## Вложенные условные конструкции {#nested-conditionals}

В примере 6 показаны условные конструкции, вложенные одна в другую. Они находятся внутри логических блоков кода условной конструкции первого уровня.

<CodeBlock language="python" title="if_statement_6.py" showLineNumbers>{if_statement_6}</CodeBlock>

## Условные выражения {#conditional-expressions}

Python поддерживает упрощённый вариант условной конструкции, называемый условным выражением.

Условные выражения записываются в одну строку и состоит из условий `if` и `else`.

Форма записи условных выражений: `инструкция if выражение else инструкция`.

Инструкция, записанная перед `if`, выполняется, если выражение истинно, в противном случае выполняется инструкция, записанная после `else`.

<CodeBlock language="python" title="if_statement_7.py" showLineNumbers>{if_statement_7}</CodeBlock>

В примере 7 на строках с 8 по 11 записана условная конструкция.

На строке 14 приводится эквивалентное условное выражение. Прочитать его можно так: «Выполнить инструкцию `print('a равно 1')`, если преобразование к булеву типу выражения `a == 1` возвращает ссылку на константу `True`. В противном случае выполнить инструкцию `print('a не равно 1')`».

<CodeBlock language="python" title="if_statement_8.py" showLineNumbers>{if_statement_8}</CodeBlock>

В примере 8 показано, что при помощи условных выражений можно связывать переменные с объектами так же, как это можно делать в условных конструкциях, что было показано выше в примере 4.

На строках с 8 по 11 приводится условная конструкция, в которой переменная `a` меняет значение в зависимости от условий.

На строке 16 записано условное выражение, которе не может быть выполнено, так как внутри условных выражений нельзя использовать операторы присваивания. Этот код содержит синтаксическую ошибку, поэтому он закомментирован.

На строке 20 приводится корректное условное выражение, эквивалентное условной конструкции, показанной на строках с 8 по 11. Переменная `a` связывается с объектом, полученным в результате выполнения той инструкции, которая запускается в зависимости от того, истинно условие `if a == 1` или нет.

На строке 29 выполняется такое же связывание переменных с объектами, только связывается не одна, а две переменные: `a` и `b`. Множественное присвоение возможно благодаря такому встроенному типу данных, как **кортеж**. Работа с кортежами будет подробно разбираться в подсекции **[Кортежи](/docs/python-language/built-in-data-types/sequences/tuples)**.

## Дополнительные ссылки {#additional-links}

- [Ветвление](https://ru.wikipedia.org/wiki/Ветвление_(программирование))
- [Составной оператор](https://ru.wikipedia.org/wiki/Составной_оператор)
